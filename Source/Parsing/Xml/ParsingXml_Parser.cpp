/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::ParsingXml.parser.txt

This file is generated by: Vczh Parser Generator
***********************************************************************/

#include "../Parsing.h"
#include "../ParsingDefinitions.h"
#include "../ParsingAutomaton.h"
#include "ParsingXml_Parser.h"

namespace vl
{
	namespace parsing
	{
		namespace xml
		{
/***********************************************************************
ParserText
***********************************************************************/

const wchar_t parserTextBuffer[] = 
L"\r\n" L""
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L"// AST"
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L""
L"\r\n" L"class Node"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Text : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class CData : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content (XmlUnescapeCData);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Attribute : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"AttName\");"
L"\r\n" L"\ttoken value (XmlUnescapeAttributeValue)\t\t@Color(\"AttValue\");"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Comment : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content (XmlUnescapeComment);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Element : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\ttoken closingName\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\tAttribute[] attributes;"
L"\r\n" L"\tNode[] subNodes (XmlMergeTextFragment);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Instruction : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\tAttribute[] attributes;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Document : Node"
L"\r\n" L"{"
L"\r\n" L"\tNode[] prologs;"
L"\r\n" L"\tElement rootElement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L"// Lexer"
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L""
L"\r\n" L"token INSTRUCTION_OPEN = \"/</?\"\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token INSTRUCTION_CLOSE = \"/?/>\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token COMPLEX_ELEMENT_OPEN = \"/<//\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token SINGLE_ELEMENT_CLOSE = \"///>\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token ELEMENT_OPEN = \"/<\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token ELEMENT_CLOSE = \"/>\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token EQUAL = \"/=\";"
L"\r\n" L""
L"\r\n" L"token NAME = \"[a-zA-Z0-9:._/-]+\"\t\t\t\t\t\t\t\t@ContextColor();"
L"\r\n" L"token ATTVALUE = \"\"\"[^<>\"\"]*\"\"|\'[^<>\']*\'\"\t\t\t\t\t\t@ContextColor();"
L"\r\n" L"token COMMENT = \"/</!--([^/->]|-[^/->]|--[^>])*--/>\"\t\t\t@Color(\"Comment\");"
L"\r\n" L"token CDATA = \"/</!/[CDATA/[([^/]]|/][^/]]|/]/][^>])*/]/]/>\";"
L"\r\n" L"token TEXT = \"([^<>=\"\"\' /r/n/ta-zA-Z0-9:._/-])+|\"\"|\'\";"
L"\r\n" L""
L"\r\n" L"discardtoken SPACE = \"/s+\";"
L"\r\n" L""
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L"// Rules"
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L""
L"\r\n" L"rule Attribute XAttribute = NAME:name \"=\" ATTVALUE:value as Attribute;"
L"\r\n" L"rule Text XText = (NAME:content | EQUAL:content | ATTVALUE:content | TEXT:content) as Text;"
L"\r\n" L"rule CData XCData = CDATA:content as CData;"
L"\r\n" L"rule Comment XComment = COMMENT:content as Comment;"
L"\r\n" L"rule Element XElement = \"<\" NAME:name {XAttribute:attributes} (\"/>\" | \">\" {XSubNode:subNodes} \"</\" NAME:closingName \">\") as Element;"
L"\r\n" L"rule Node XSubNode = !XText | !XCData | !XComment | !XElement;"
L"\r\n" L"rule Instruction XInstruction = \"<?\" NAME:name {XAttribute:attributes} \"?>\" as Instruction;"
L"\r\n" L"rule Document XDocument = {XInstruction:prologs | XComment:prologs} XElement:rootElement as Document;"
;

			vl::WString XmlGetParserTextBuffer()
			{
				return parserTextBuffer;
			}

/***********************************************************************
SerializedTable
***********************************************************************/

const vint parserBufferLength = 4439; // 18926 bytes before compressing
const vint parserBufferBlock = 1024;
const vint parserBufferRemain = 343;
const vint parserBufferRows = 5;
const char* parserBuffer[] = {
"\x00\x0E\x00\x02\x83\x80\x07\x7D\x00\x82\x03\xFF\x45\x08\x82\x83\x86\x81\x21\x6F\x6C\x2F\x32\x37\x84\x87\x02\x86\x00\x17\x82\x94\x21\x37\x32\x27\x30\x6D\x65\x06\x98\x8A\x80\x8E\x86\x00\x10\x92\x94\x98\x8A\x88\x85\x96\x8E\x1E\xA0\xA2\x95\x88\x85\x90\x87\x93\x29\x93\xB4\x84\x8D\x94\x9F\x81\x20\x74\x74\x1F\x81\x93\x94\x86\x9A\x84\x38\x91\xBA\x98\x88\x04\xA7\x9F\xA0\x56\x61\x2C\x35\x33\x9C\x93\x92\x82\x49\xAA\xBB\x83\x8D\x9C\xAF\x80\x98\x43\xD5\x86\xB7\xA3\x81\xAF\xA4\x86\x4D\xE8\x83\x82\x2F\x35\x3A\x36\x32\x61\x72\x39\x25\xA5\x9C\xB1\x87\x81\x39\xAB\xAA\xBB\xB0\x04\xB6\xB6\xB8\x72\xF4\x84\x87\xA8\xA8\xBE\xA4\xBD\x08\xE9\x89\xCB\xBD\xB7\xB5\xB9\xB9\x5B\x82\x84\xC5\xB6\xC2\xAE\xA6\xBE\x7E\x8E\xC1\xD1\xC5\x86\xB8\x00\xB3\x88\x84\x8A\xC2\xDC\xC7\xBF\xC6\xC1\x09\x9E\xE0\xDC\xC3\xD3\x82\xC5\xCC\x80\x90\xE4\x8C\x08\x8C\xDB\x87\x37\x6E\x74\x25\x38\x34\x39\xBC\x8D\x82\x9C\xFF\x76\xC8\x83\xE0\x89\xDD\xDD\xBD\x87\xFF\xC8\xD2\xCA\xD5\xCB\xB3\x2E\xAC\x86\xCD\x31\x91\xDD\xD6\x81\x09\x18\x99\xE2\x80\xA4\x3A\x39\x34\x62\x75\x3A\xDF\x74\xF5\xF0\xF2\xE7\x0F\xC4\x21\x34\x31\x36\xF2\xF3\xAE\x02\xAD\x90\x94\xE5\x31\xDE\xF7\xF2\xD7\x80\x0A\xC4\x2F\x33\x31\x3B\xEA\x74\x37\x74\x78\x7C\x19\x43\x45\x10\x1B\x65\x00\x82\x83\x3F\x0B\x18\x4D\x82\x40\x49\x2E\x13\x1E\x77\x75\x23\x14\x1D\x1A\xB8\x4B\x84\x00\x46\x1B\x82\x4E\x13\x1B\x64\x22\x42\x81\x87\x08\x64\x84\x14\x72\x0B\x8D\x0A\x77\x8A\xDC\x41\x5F\x75\x78\xBA\x64\x84\x40\x89\x6E\x32\x42\x00\x8B\x08\x5B\x70\x01\x77\x2F\xA2\x75\x18\x7A\x00\x36\x12\x54\x55\x03\x26\x46\x91\x7A\xEB\x61\x14\x81\x4B\x63\x38\x6A\x6E\x7D\x02\x8B\x93\x74\x80\x52\x82\x4D\x93\x71\x50\xB7\x79\x7F\x7E\xFD\x7F\x75\x7C\x1D\x55\x80\x00\x1E\x1C\x4A\x67\x13\x1F\x82\x5B\x83\x4C\x7E\x7F\x00\x8F\x88\x42\x9B\x64\xAF\x14\x1F\x81\x09\x9F\x9B\x81\x98\x74\x80\x8A\x00\x46\x7B\x82\x4B\x7A\x77\xE0\x7E\x87\x99\x94\xD2\x42\x49\x9F\x97\x6E\x84\x4E\x9B\x18\x12\x73\x19\x1A\x1B\x31\x61\x4C\x64\x9E\x08\x80\x82\x8F\x40\x34\xB2\x4F\x6C\xA5\x75\x96\x77\x64\x00\x73\x35\x12\x1B\x87\x21\x83\xA7\x7D\xA2\x03\x6E\x91\x87\x84\x72\x15\x87\x84\x6E\x7D\x88\x41\xAF\x9F\x3D\xBA\x66\xAA\x7B\xA8\x82\x4A\xAA\x84\x14\x96\x88\x86\x1B\x97\x82\x49\xA5\x48\xC1\x80\x05\xB2\x89\xC8\x61\x97\x97\x93\x01\x82\x80\x04\x46\x31\x18\x4F\xB3\x6F\xD4\xB5\x4B\x82\x80\xD5\x86\x57\xB7\x7D\xD9\x96\xBB\xB6\x79\xDD\x83\x6F\xB6\x79\xD3\x88\x45\xB9\x12\x4E\x13\x14\x16\x14\x55\x03\x14\x15\x12\x4F\x0E\x1F\x17\x13\x50\x05\x1E\x13\xB1\x03\x6F\x0C\x0F\x0B\x3F\x3F\x6E\x65\x04\x18\x40\xC0\x85\xBA\xEB\xAD\xBF\xB9\xBC\x5F\x03\x1C\x13\x13\x53\x05\x18\xBE\x40\xFC\xAF\x0E\x0C\x67\x06\x18\x44\x06\xC5\x78\x4F\x1D\x10\x14\x4C\x05\x18\x17\x17\x45\x1D\xCD\x12\xBD\x54\x33\xB5\xBF\xBD\x1C\xB9\xBB\xBF\x0B\x37\x96\x48\xC4\x43\x17\xC2\x43\x14\xBA\x47\x1D\xC0\xCA\xC8\x24\xC9\xCB\xC1\xC3\x0F\xC0\x0F\x0B\xCF\x3E\x05\x9C\x5C\x41\xC3\x44\xD6\x80\xCE\x4E\x25\xC4\xBE\xBD\x2D\xC8\x4D\xD2\xBE\xC5\xBA\x84\x42\x8A\x0C\x54\xD0\x01\xC8\x45\x23\xC9\xD2\xCE\x0C\xC5\x1D\xD0\x41\x4F\xFE\x0E\x65\xAC\x85\x77\x46\x81\x14\x55\x01\x1C\x13\xD7\x03\x4F\xDD\x0D\xC5\xDA\xB7\x7D\xCE\x13\x41\x23\xC2\xC0\x42\x77\xDB\x11\x19\x0B\x7A\x01\x1D\x0A\x16\x30\x2D\x09\x0E\x0E\x2E\x1F\x1F\x09\x0B\x5D\x2B\x04\x81\xAE\xFA\x5F\xA1\x10\x15\x54\x16\x1A\xD9\x15\x45\x13\x08\x46\xE5\x02\x62\x0B\x16\x17\x3C\x3E\x02\x09\x17\x2A\x22\x0C\x1F\x09\x9B\xDD\xE7\x08\xE8\x27\x39\x75\xD2\x57\x2E\xCF\x4A\xC6\xD6\x54\x22\x08\x46\xEC\x10\xFB\xB1\x09\x0B\x2D\x28\x0B\xE7\xE1\x3E\x1D\x1C\x1D\x0B\xBB\xED\x0D\xEF\xEF\xC0\xDE\x1D\xED\x0A\x2A\x38\xE2\xC6\xD4\x03\x56\xD5\xD8\x52\x78\x44\x1F\xE1\x10\x2C\x18\x45\xF5\xED\x2F\x21\x0F\x0B\x16\x43\x12\xF4\x15\x10\xDB\xFA\xEE\x17\x0B\x5D\x3E\xE4\xFB\xEE\xE5\xFC\x14\xFB\xF9\xC6\xDD\x18\xF3\xFA\x5D\x12\xC4\xD9\x42\x23\xA9\xCB\x46\xC7\x54\x24\x08\x46\xFE\x02\x62\xFD\xE5\x0F\x22\x07\x04\x08\x2F\x02\x0F\x17\x2E\x0F\x05\xEC\x3C\x6E\xDF\x00\x72\x70\xC2\x46\x70\x71\x29\x0B\x04\x1F\x22\x77\x04\xC6\x4B\x44\x33\x40\x53\x08\x14\x41\x03\x09\x22\x02\x68\x21\x1F\x8F\x07\x1C\x2B\x0B\x74\xC9\x02\x41\x5A\x0C\x33\x7E\x40\x31\x58\x0A\x1E\x41\x52\x37\x31\x68\x21\x0C\xAD\x8E\x45\x17\xA5\x0E\x05\x52\x0F\x0E\x9C\x53\x0C\x3C\x39\x34\x0F\x01\x18\x20\x8A\x40\x40\x00\x04",
"\x12\x3C\x04\x86\x80\x50\x45\x19\x3E\x0A\x84\x00\x2C\x86\x85\x4A\x85\x5C\x41\x65\x58\x89\x5A\x77\x84\x87\x71\x34\x0D\x40\x0C\x2B\x8A\x00\x04\x8F\x88\x50\x9E\x44\x13\xFC\x43\x21\x2A\xB6\x85\x84\x00\x03\x3A\x19\xCA\x8E\x05\x18\x3C\x00\x23\x6F\x82\x20\x18\xB5\x8A\x88\x1F\x3A\x00\x04\x74\x63\x64\x08\x77\x85\x47\x90\x04\x8A\x04\x00\x80\x07\xE3\x11\x73\x73\x22\x3B\x88\x04\x42\x53\x29\x19\x20\x01\x0D\x39\x02\x94\x8E\x3E\x4D\x8B\x13\x90\x9A\x36\x34\xAA\x89\x8C\xBA\x2E\x06\x0C\x71\x88\x20\x4E\xB3\x89\x89\x62\x97\x8D\x1E\x86\x9C\x8E\x99\x20\x00\x90\x22\x04\x8B\x20\x92\x7C\x08\xCA\x47\x91\x91\x54\x2C\x92\x23\x98\x95\x0C\x49\xA5\x8C\x96\x96\x97\x94\x25\xB7\x83\x06\x4E\x84\x26\x93\x6B\x81\x94\x1E\xF5\x64\x94\x10\x3D\x8B\x91\xA8\x82\x90\xE4\x2C\x9E\x95\x3B\xB0\x93\x91\x8D\x8F\x90\x28\xBA\x30\x08\x5B\x82\x21\x98\xBA\x32\x00\x46\x5A\x97\x9A\x5A\xB8\x82\x87\x73\x4F\x2E\x10\x88\x23\x9C\x23\x98\x9B\x89\x20\x00\x09\x9A\x57\x97\x51\xDC\x16\x98\x00\x58\x0D\x9C\x1D\x1A\x9E\x01\xC8\x35\x9A\x8E\xF1\x95\x53\x97\x76\x87\x94\x1E\x22\x03\x98\x7A\x85\x96\x1F\xA0\x0B\x0E\x10\x27\x9F\x90\xB4\x56\x86\x23\xFD\x00\x04\x14\x27\x92\x62\xFF\x9C\x0F\x29\x9E\x74\xA0\x83\x93\x0A\x54\xA4\x4B\x93\x1D\xA1\x53\x54\x10\x65\x0B\xA1\xFD\x8F\x07\x3F\xA3\x97\x90\x46\x6F\x0E\x51\x90\x41\x2F\x44\xFF\x99\x04\x59\xA0\x02\x9E\x0D\x0A\x03\x11\xF2\x9C\x9E\x11\x3E\x98\xA0\xC5\x87\x99\x3A\x85\xA7\xA1\x3B\x89\xA2\x89\x20\xAE\xA2\x08\x10\xA0\x04\x89\xA2\x04\xA2\x3C\xB7\xA1\x47\xA1\x47\x90\x8E\x99\xA0\xA4\x36\xA2\xA4\x4E\xA5\xAD\x51\x47\x51\x50\x99\x14\xAD\xA5\x34\xF2\x99\x97\x6B\xAB\x55\x57\xAF\x4E\x0D\x17\x84\x2D\x8A\x2C\x1F\xAD\x55\xBE\x58\x36\x26\xA4\x18\x22\xB6\xB8\x9F\xAC\xAE\x5F\x55\x4D\xBC\x0F\x07\x91\x84\x9F\x90\xC7\x84\x88\x4F\xB4\x98\xA1\x5D\x90\xAF\x07\x14\xB1\x98\x5C\xE9\xAE\x0D\x98\x87\x8B\xB0\x61\xB3\xAD\x5D\xD3\xA2\xA1\x45\x80\x0B\xAF\xBB\x9D\xAF\x34\x9F\xA0\x04\x86\xA2\x00\xB0\xFF\x82\xB0\xAF\x68\xA1\xAD\x75\xB0\x9A\x9E\xEF\x99\x9D\xA7\x73\x94\x07\x7B\x88\x26\xB4\x33\xBA\x9D\x6E\x73\xA6\xAF\x80\x86\x9E\x94\x90\xB3\xB2\x64\xD6\x81\xA9\x87\x94\xA6\xA8\x9E\x7A\xAE\x45\x98\xAE\xA3\xA6\xBC\xB5\x54\x95\xA1\xA5\x6B\xC5\x96\xA4\x94\x97\xAB\xA5\x20\x1A\xAA\x23\xB0\xA2\xA6\xD1\x80\x44\xB5\x8C\xAF\xB5\x48\x15\xAD\xA6\x46\xBE\xA9\xB8\x42\xA4\xA8\x6E\xFF\x9F\xB1\xDD\x8B\xAA\xA3\x20\x0E\xAA\x47\xD0\xAB\x5F\xE1\x94\xAF\xA4\x56\xAA\xA7\x51\xAC\xAE\xA4\x79\x9E\xB6\xB9\x5F\x41\xB6\x3C\xAE\x03\x06\x43\x18\x26\xBE\xF8\x94\xA7\x1D\xB6\xA6\xBD\xC6\x94\xBC\xAF\x3E\xB7\xB8\x43\xD9\xB7\xB6\xE4\x89\xAF\xB7\xE0\xA2\xBC\x70\x96\xB5\xBD\xE8\x85\xB9\xBD\xA6\x8B\xBD\x72\xED\xBA\xB4\x3A\x00\x0D\xAB\xF0\x88\xB3\xAF\x63\xA3\x21\xB2\x9A\xC2\xAD\x33\x11\x08\x46\x22\xCF\xAD\xCD\xB1\xA8\x37\x8A\xBD\xBE\x74\x8B\x91\xB6\x2B\xB3\xB2\xA1\xC1\xB7\xB1\x60\x8E\x9F\xC2\x37\x2A\x9F\x53\xF0\xAE\x9C\x19\xEC\x95\xC2\x17\x36\x00\xBF\x08\x20\xC9\x6A\xA3\xB0\xBA\x92\xBE\xBD\xC5\x36\x8F\xC4\x50\xD8\xB6\xB7\x88\x86\xC6\xBB\x19\xBE\xB7\x77\xE4\xB2\xA4\x22\x86\xC8\x04\x0F\xC9\xA5\x84\xD9\xA4\xC3\xD1\x80\x48\x0B\x27\x5C\x35\x98\x60\xC8\x39\x36\x98\x08\x23\x67\xD8\x9D\x98\xF4\x0C\x9F\x2B\xCB\x5F\x4B\x45\xAF\xA4\xDA\x6A\x65\xA4\x27\x70\xCA\xA2\xAB\x85\x91\x9D\xD8\x44\x0F\x38\xD4\x08\x7F\x7B\xCC\x5A\x4B\xEB\xC0\x08\xB8\x48\x26\xD0\x58\x1D\x79\x92\x6F\xBA\xD0\xF6\x2D\x8B\x04\x18\x30\xD0\x3E\x8D\xD1\x0C\x7E\x9D\x7B\x7A\x81\xD0\xCD\x34\x94\xD7\xC6\xBE\x09\xD7\x0D\xF4\x3A\xC5\x0A\xE5\x83\x3E\x00\x6D\x89\x05\x18\x28\xD7\xA4\xA0\xDF\xB9\x3B\x83\x0F\x75\x24\x79\xD1\x6E\x2E\xA5\xD5\x2F\x5D\xD3\x31\x3C\xC3\xB6\x7C\xBD\xC1\x06\x20\xC4\x22\xC8\x39\xCC\xCF\x7E\xFE\x96\xCB\xBB\x87\xCE\xA0\x00\xD6\xBB\x64\xB5\xB3\xA9\x02\xD2\xC7\xC0\xDF\xB2\xCB\x53\xB1\xCD\xC0\x37\xD5\xAA\xCB\xD3\xB2\xC2\x72\xAF\xA5\xC3\xF7\xB2\x9A\x8A\x03\x34\x8B\x7C\xB9\x82\x4F\x22\x2F\x2E\x79\xCD\x63\x22\x39\xB4\xA9\x9D\xF7\x8A\xA9\xA3\xA1\xAF\xDE\x47\xED\x85\x06\x8C\x35\xD8\x9F\xF2\xC1\x44\x3F\xA1\x04\xCC\xDE\x31\xCC\xDF\x94\xDF\xDF\xA7\xA1\xDD\xCE\x89\xBC\xDA\x9E\x40\x0C\x78\x76\x65\x8B\x4C\x2F\x79\x34\x71\x6E\x58\x09\xC3\xA6\xD1\x06\x30\x18\x26\xE2\xF8\x93\xE3\x3E\xF7\x8C\xA7\x1A\xC7\x93\x4C\x65\x4E\x92\x44\x83\xE0\x41\x8F\xE4\x4A\x22\x66\x41\xB9\xB0\x87\x91\x4F\x39",
"\x55\xC6\xA5\x1A\xF9\x37\x85\xB5\x35\x8D\x1A\xF1\x84\x20\x33\x95\xC7\x37\xE5\xDF\x2D\xBB\x44\x27\x6E\xE6\x95\xC6\x0F\x69\x9A\xE0\x00\x3A\x42\xE2\x5D\x4D\x4E\x83\x0C\xE9\xE9\x2F\x5A\x90\xE3\x08\x30\xEB\x11\xB1\xE2\xD9\x9D\x86\xA6\xE3\x77\x80\xE4\xCA\xA2\xE6\xA1\x5A\xF3\xD1\xEB\x27\xEF\x0D\xCA\x8C\xAB\xE5\x3B\xAD\xE2\x9E\x30\xED\xEA\xA7\x1E\xD0\xB5\x1D\xDF\xB5\xC7\x37\x1E\xD7\x40\x40\xDA\xBF\x7E\xAA\xC2\xA7\x48\xCA\x8A\x92\x82\x5C\xC9\x66\xCE\xCF\xD9\x50\xDD\xB7\x46\x88\xC4\xCA\x15\xD9\xCF\xAA\x7F\x9C\xCB\x56\x95\xCF\xCB\x35\xE8\xDA\x20\x56\x7D\xDF\x3C\xE4\xD1\x9C\x32\x2F\x9E\x9C\x6B\xC3\xE9\xA1\x98\x28\xD0\x4A\xDC\xC2\x20\x65\xB4\xD3\xCE\x95\xF0\xE2\x75\xC7\x8C\xD2\x9A\xEC\xD0\xAB\xDF\x40\xDC\x81\x14\x8E\xEB\x93\xE0\x9E\xB9\xE4\x0F\xF0\x00\x16\x6E\x9C\xB0\xE9\xF4\x8E\xF9\xD5\x0D\xD6\xC0\x04\x8A\xBC\xE3\xF7\xEC\xB5\xF7\xF7\x23\xBC\xF2\xF3\x45\xE7\xE8\xD5\xBE\xE3\x21\xBB\x48\xEC\x4D\x4E\xF4\xF3\xEC\x9F\xF0\x20\xD3\xCF\xFE\xE1\x6C\xC9\x9C\x86\xE6\xA6\xC4\xC2\x94\xFE\xC3\xDD\xE1\xAD\x1B\xA4\xC8\x20\xF2\xC7\xB1\xFC\x72\xA3\xD9\x5D\xC5\xDE\xB4\xBC\xC8\xD9\xB2\x01\xCB\xD9\x8C\x98\xBE\xA5\x1A\xCD\xF0\x39\xE3\x84\x23\x38\x92\xF3\xF4\x2C\xBE\x87\x9D\x44\x48\x79\xC8\x12\x36\x47\x20\x4F\x6B\x65\x7A\xD7\x4B\x66\x2E\x0E\x7F\x74\x09\x7C\x03\x1F\x45\x92\x7E\x03\x86\x64\x10\x9D\x7A\x1E\xEC\x1E\x7B\xAF\x76\x81\x61\x0D\x7F\x3D\x44\x07\x08\x8E\x45\x45\x47\x7A\x1A\x82\x81\x9C\x74\x6A\x1A\x8B\x7D\xA2\x7C\x80\x00\x80\x02\x22\x89\x24\x3E\x0A\x7A\x04\x7C\x4D\x08\x12\x83\x24\x71\x7D\xE0\x4C\x80\xC4\x7F\x80\x21\x85\x83\xAB\x50\x83\x00\x2F\x7D\xA4\x6B\x7A\xB9\x1B\x80\x1D\x88\x61\x10\x89\x7B\xDE\x65\x61\x32\x84\x10\x34\x83\x6E\x37\x8D\x81\x39\x83\x44\x3B\x84\x53\x49\x83\x5A\x40\x89\x6B\xA6\x6C\x80\x46\x8C\x82\xC1\x6F\x82\xBB\x78\x60\x4B\x83\x10\x34\x81\x7C\x94\x78\x83\x18\x16\x35\x01\x86\x7C\x08\x6E\x85\x9E\x6C\x7B\x57\x80\x4F\xC1\x7A\x85\x34\x72\x85\x6A\x8F\x5D\x3E\x0B\x7D\x35\x66\x01\x18\x1A\x87\x5E\x58\x7E\x6A\x55\x86\x1D\x8C\x7C\x02\x17\x37\x69\x8C\x7D\xAC\x27\x62\x6E\x07\x87\x73\x89\x61\x7E\x8E\x06\x61\x82\x10\x34\x8A\x73\x0C\x88\x81\x3A\x87\x7E\x87\x84\x58\x3E\x0E\x80\xD7\x44\x75\x98\x38\x10\x9D\x87\x7D\xA6\x60\x88\x59\x4F\x86\x85\x84\x75\x99\x88\x23\xA0\x8F\x25\xF9\x73\x10\xFB\x74\x75\x44\x89\x45\x51\x80\x82\x53\x7A\x76\x6C\x61\x5A\xB8\x4B\x88\xE7\x4E\x02\x34\x0E\x4B\x03\x10\x4C\xB4\x4D\x66\xC6\x6B\x62\xA7\x41\x48\x79\x6D\x4A\xC5\x4F\x4C\x2E\x54\x4B\x40\x07\x7F\x62\x65\x28\x06\x85\x66\x32\x09\x66\x08\x12\x8D\x47\x49\x79\xA2\x41\x8C\x6F\x63\x6B\x12\x55\x04\x73\x6C\x04\xB2\x65\x70\xCA\x44\x48\xC6\x8F\x8D\x7E\x60\x68\x77\x49\x8D\x7D\x61\x4D\x84\x63\x81\x03\x15\x81\x8B\x68\x63\xA2\x72\x03\x92\x68\x10\xF3\x8D\x82\xEC\x16\x69\xDE\x31\x04\xE4\x8B\x69\x1A\x87\x6B\xA4\x17\x4D\xB0\x71\x5A\xB0\x7A\x49\xAA\x68\x10\x05\x97\x7A\x42\x85\x75\xAF\x6D\x04\xB0\x3B\x8F\x8E\x40\x7B\xFE\x8E\x1A\x65\x4D\x76\xA3\x68\x85\x4E\x75\x03\x72\x72\x10\x74\x75\x61\x45\x61\x8C\xEE\x75\x5D\x3F\x5C\x77\x03\x6D\x64\x71\x60\x78\x58\x0C\x7B\xD2\x63\x5E\xD4\x62\x55\xD6\x68\x5E\xD8\x68\x55\xEC\x5B\x78\xA3\x53\x73\x0C\x1A\x46\x35\x6F\x86\x86\x80\x56\xBF\x2A\x8B\xE4\x74\x10\xE6\x79\x93\x9C\x59\x7E\xFD\x4B\x58\x57\x6F\x91\xC9\x61\x92\xB6\x23\x7F\x33\x60\x02\x35\x69\x70\xA8\x84\x75\x1F\x89\x8A\x43\x83\x03\x50\x74\x10\x52\x72\x95\x55\x7D\x71\x8D\x86\x72\x21\x71\x67\x3C\x8D\x67\x60\x7D\x95\x64\x78\x76\x66\x72\x7B\x2F\x71\x4D\x54\x71\x91\x2B\x4E\x76\xE7\x4A\x89\x3B\x2B\x4B\xE1\x24\x3F\xF7\x1C\x8C\x74\x0D\x33\x6B\x6F\x1B\x1C\x04\x12\x02\x2C\x8E\x02\x1E\x8E\xEC\x10\x24\x94\x6F\x1B\x1E\x0A\x97\x5A\x20\x8F\x09\x91\x26\xB0\x7F\x1B\x20\x04\x98\xEE\x15\x85\x54\x2E\x8C\xF2\x4F\x1B\xB4\x3E\x2D\x8D\x9F\x85\xDF\x53\x37\x1E\x5F\x1B\xFC\x34\x99\xE6\x18\x87\x8D\x8F\x81\x35\x6F\x1B\x26\x0C\x98\xE6\x1E\x96\x58\x9E\x59\x54\x7F\x1B\x28\x04\x9A\xE5\x10\x01\x1F\x49\x10\xC1\x1F\x1B\x9C\x11\x97\xB4\x95\x9B\x35\x11\x1C\x8C\x3C\x36\xB6\x90\x00\x9C\x13\x9B\xF6\x35\x22\x03\x17\x4C\xBF\x16\x8B\x70\x91\x2E\xCC\x15\x10\x4D\x4F\x9A\xBB\x9B\x9C\x24\x11\x1C\x68\x45\x2C\xB5\x9D\x9B\xB4\x90\x24\xCF\x43\x9C\x6C\x94\x4B\x83\x11\x1C\x18\x4C\x9C\x03\x1E\x9B\x71\x9E\x96\xD8\x9E\x76\x04\x13\x49\x93\x5F\x0F\xBA\x95\x10\xE7\x94\x20",
"\xB2\x9E\x8C\x04\x1A\x9C\xBB\x90\x9E\xC5\x95\x91\xB2\x2A\x4B\x93\x5C\x97\x05\x2C\x9D\x4E\x47\x9D\xBB\x47\x9E\xD6\x92\x9F\x48\x9F\x51\xBF\x1E\x99\x97\x81\x56\xE6\x95\x82\x71\x94\x31\x18\x1E\x9E\xB6\x90\x9F\x93\x5D\x9F\xF3\x9D\x4D\xBB\x46\x9F\xF6\x95\x9B\xC4\x93\x59\xFC\x92\x9E\x03\x13\x2B\x7E\x5F\x1B\x8E\x9F\x25\xF8\x91\x97\xC7\x9F\x0F\x04\x25\x74\x1F\xA2\x19\xC1\x15\x74\xF9\x15\xA2\xC0\x14\x12\xB9\x9F\xA1\xE7\x9E\x19\x13\xA4\x9B\x1D\xA9\x1B\xDE\x90\x9C\x0C\x13\x2C\x65\x0E\xA0\xE3\x94\x9F\x56\x44\x2D\x21\xA3\x36\x2A\xA9\x2D\x21\xAD\xA2\xF8\x9F\xA2\xEC\x9B\x9C\x02\xAA\x93\xB8\x15\xA3\x33\x2F\x9B\xC2\x98\xA1\x6B\x90\xA1\x0D\xAE\xA3\xC1\x16\x9F\x8C\x3A\xA2\x21\xA9\x1F\xAB\x8B\x9B\x46\xA3\x34\xCB\x93\xA3\x74\x0E\x19\x25\x0F\xA1\xEE\x68\x60\x2B\xA6\x14\x4D\x48\x46\xB5\x9A\xA0\x9E\x19\xA2\x32\xA8\x63\xF2\x42\xA6\x64\xA6\x99\x19\x5C\xA4\xAC\x31\x1D\x56\x26\x67\xB9\x1E\x2F\x05\x82\x79\x43\xAB\x88\xCC\x9C\xA6\x9F\x2C\x9C\x60\xA2\xA7\xF8\x95\xA6\xDF\x56\xA7\xF1\x1E\x8C\xE8\x8C\xA7\x66\x39\x80\x28\x2E\x9C\x80\xAB\x9C\x82\xAE\xA5\xBB\x95\xA8\x18\x13\xA6\x87\xA4\xA7\x1E\x5A\xA8\xF7\x98\xA7\x00\x0D\xA8\x05\x8F\x3C\x7E\xA1\x1C\xB5\x74\x7D\x6B\xA3\xAA\x12\x9B\xA9\x6C\x7C\x78\x99\xA3\xA7\x6D\x88\x60\x9E\xAA\x2C\x7A\xA4\x07\x1C\xA6\x98\x04\x71\xA2\xD4\x75\x7B\xA9\xAF\xA8\xB8\x6C\x9D\x98\xAC\x10\x9A\xA0\xAC\x9C\xA1\x22\xB3\xAC\xA8\xB5\xAF\x1B\x12\xA6\x82\x49\x21\xA2\x5B\xA9\x46\x1F\xA5\xA9\xBF\xA4\xA8\x70\xAE\xAA\xC2\xA0\xAB\xBF\xA7\x92\xB2\xA4\x9B\xB4\xAC\x67\x8E\xA0\x3D\x90\xAC\x1B\x67\xA7\x9B\xD2\x2F\xA1\x9E\xAB\x29\x90\x95\x61\xB7\xAD\xAA\xA3\x5F\x0F\x0A\xA5\xA0\x0C\x1F\x88\xD4\x2C\x19\x05\x9D\x9E\x1F\xAC\x29\x00\x2B\xAE\xD9\xA2\x4F\xF6\x95\xAF\x5F\xA5\xAD\xA3\x5E\xA9\x1F\x87\x76\xEA\xA8\x23\x04\x1A\x7C\xB4\x80\xAF\x78\x34\x9B\x9C\x13\xAC\xF6\xA8\x9F\xF8\xAE\xA1\x83\xAB\xAA\x6F\x73\x5A\xF6\x9E\xB0\xFF\xAC\xAE\x00\x2A\xA0\x25\xA8\xA8\x19\x5A\xB0\x4C\x8C\xB0\x2F\x30\x42\xF7\xA9\xAE\xA3\x5A\xAF\xFF\x85\xB1\x00\x26\x9F\x37\x79\xB1\xFB\xA5\x61\x02\xBB\x74\x02\x14\xB0\x27\xB6\xB0\x03\x18\xB0\xD0\x7B\xA7\xC6\x9A\x9D\x97\x36\xAE\x1F\xA0\x9A\x8D\x81\xA0\xB8\x85\x63\x20\xB9\x10\xE7\x9D\xB2\xD5\x24\xAF\x09\xAF\xB3\x32\xB0\x00\xA1\x93\xA9\x02\x16\x93\x8D\x8D\xAF\x1F\xA9\xA4\x41\x98\x1B\x17\xAD\x3A\xA0\xAA\x75\x62\x73\x07\xBF\x16\x9A\x54\x75\xB4\x02\x18\xB4\xF3\xA3\xB2\x0F\xBC\x9D\x40\xB3\xA0\xBF\x22\xB4\x35\x95\x73\x53\xB6\xB6\x48\xA3\xB4\x8D\x89\xB5\xA0\xAE\x13\x02\x1C\xB5\x66\x2F\xB5\x4F\x94\x8B\x25\xAF\xA7\x0C\x15\x01\x3E\xBC\x10\x31\xBC\x10\x8B\x27\x6D\x57\x58\xB2\x14\xB1\x6C\xE4\xA6\x14\x9C\x1C\x87\xDC\x97\xAE\xBF\x9D\xA4\x1B\x18\x1C\xDF\xA4\xAA\x6B\x61\xA2\xE7\x92\x88\x65\xB7\xAD\x0C\x1C\xB1\xB4\x96\x97\x94\xBA\xAA\x77\x11\xAE\x74\x07\xB1\x1F\xA4\x97\x9E\xBC\xAA\xD9\xAC\x7B\x20\xAC\xB3\x0C\x17\x01\x81\xBC\x9D\x80\x9A\x81\xCA\xA6\xA0\xF0\x44\x69\x98\xB1\x30\x22\xBC\xB9\x24\xB8\x9F\xB3\xB9\x24\xB5\xBC\x10\x7E\x91\x06\xA6\xB8\x9F\xCB\xA0\x90\x1A\x89\xBA\xC4\xA1\xAB\xDF\x5D\xBA\xCD\x98\x11\x18\x01\xBB\xCC\x98\x98\x09\x98\xB8\x02\x1A\x18\x5F\x9E\xAE\x24\x17\xB4\xBB\xB6\x90\x4B\xB0\xB1\xCE\x89\x98\x13\xB7\xBD\x41\x84\x70\x54\xBA\xBA\x29\xBF\x95\x74\xB6\xB7\x5B\xB1\x76\x79\xB6\xB3\x0B\x7B\x89\x09\xB9\xB9\xDD\xB4\x10\x18\xB2\x10\xCA\xBD\x2D\xD4\xB4\x70\xD6\xBD\x38\x00\x99\x90\xC5\xBB\xBC\xD9\xA0\x7B\xF9\xBE\xB2\xE9\xBC\x7B\x62\xB0\x00\x64\xBB\x9E\x30\x3F\xBD\xDC\x9B\xBF\xF9\xA3\xBE\xFE\xB7\xBB\x00\xC0\xB7\x97\xA8\xAB\x00\x2B\xBE\x77\xAC\xBE\x78\xBE\xB5\xF0\xB6\x74\x4C\x79\xB3\xB6\xAF\xA1\x7E\xB7\x68\xD2\xBD\x9D\x9F\xBE\xA4\x9A\x22\xC1\xD8\xB1\x99\xCC\x91\xA2\x9C\x19\x01\x41\xAB\xB8\x35\x17\x9E\x6E\xA2\xB8\x12\xC7\x9E\xF6\x97\xC3\xE1\x2E\xB1\x1E\x5A\xC1\xE4\xBC\x17\x0A\x60\xA0\x2C\xC3\x91\x05\xBD\x2D\x30\xC8\x11\x1A\x07\xC2\x17\xCC\x17\xA9\x9F\xC1\x38\xB8\x7D\x33\xCF\xBC\x46\x15\x2C\x1B\x0C\xC4\x9F\x16\xC1\x0B\xAB\xB7\x22\xC0\x9B\x24\x1A\xA5\x58\xCE\x19\x0B\xC4\x9B\x60\xBC\xB7\x5E\xC6\x14\xA7\xAE\xA2\xA2\xBA\xC0\x1F\xA5\xC6\x22\xC7\xAC\x5A\xB2\xAA\x96\xA3\xC1\x5F\x92\xA4\x27\xAF\xC1\x53\xC9\xC7\x7A\xCB\xC7\x67\xC5\x13\x8C\x3A\x9E\xF5\xB8\xC2\x71\x9D\x33\x4F\xAD\xB6\x86\xCC\x88\x6A\xB8\x1B\xD9\x94\x12\xBF\x1D\x01\x7C\xCD\xB7\xC1\x19\xA6\x58\xC0\xC7\xA0",
"\xA2\xC7\xE0\xA7\xC9\xA5\xAC\xA2\x50\xB6\x9B\xD2\x91\x97\xDD\xAC\x2C\x95\xB4\x19\xA4\xB1\xA2\x18\x6C\x9C\x9D\xC1\x2E\x9F\xC2\xB1\xBE\xA6\xB9\xA1\xBE\xAC\x9B\xC1\x9D\x18\x14\xC9\xEC\xB6\xC9\xCF\x3C\xCA\xBC\x11\xA2\xBF\x1F\x01\x8F\xC3\xC3\xBA\xA7\x86\x93\xCC\xAD\xC8\xAE\xAD\xB6\xB4\x81\xCC\xAC\x1E\xE3\xA3\x18\xBF\x11\x02\xBB\xC8\xA5\xA6\xA8\x11\xA8\xA1\xC8\x02\x12\xCB\x77\xA4\xCB\x14\xB9\xBE\xE2\xB8\xCB\x91\x6B\xCC\xCB\x99\xA5\x41\x4A\xCD\x26\xAC\xC8\xAF\xAE\xCD\xB5\x9C\xCD\x0C\x1F\xAC\xB0\xCB\xCA\x03\x17\xBF\xB6\x9E\xC3\x21\x27\xCC\x09\x12\xC9\x45\xAB\xC6\xEA\xC5\x9B\xEC\xC5\x06\xD2\xCB\xA8\x79\xA2\xCC\xE8\xC3\xBA\xCF\x87\xCB\xB8\x9F\xCA\xB4\x9D\xA5\x08\x13\xCF\x6F\xAC\xBC\x75\xA0\xCC\x71\xC9\xAC\x6B\xC7\x12\x99\xC6\x14\xA5\xCB\x9C\x02\xD6\xBF\xD8\xA7\xC0\xDB\xAE\xC9\xC1\xC0\xCA\x0B\xD5\x46\x97\xBD\xCC\x5C\x4A\xC6\xFB\xC0\x00\x04\xD1\x97\xF5\xC7\xCF\x9F\xA4\xCD\x41\xC3\xC0\x09\x9D\xCB\x55\x3E\xD1\x97\xC2\xD1\xE8\xB9\xB8\xBC\x74\xD2\x4C\x2A\xD0\xC2\xB6\xBB\x89\x6A\x81\xAE\xC7\xC8\xCC\x91\xD1\xE9\xC3\xD1\x30\xD5\xD1\xA8\xC7\xD1\xAA\xCD\xD2\xA2\xCD\xCF\x01\x21\x9B\x18\x17\x02\xE2\xC8\xC4\xC1\x16\xC5\x4B\xDD\xC7\xC8\xC9\x6A\x4F\xD5\x2D\x21\xAE\xD4\xF8\x9B\x9D\x0C\x1E\xAF\xEF\x9C\xC5\x52\xCF\xCD\x46\x10\xC6\x57\xDB\xC6\x5A\xDB\xC5\x0C\x11\xC5\x11\xCE\xD5\x35\x19\xC6\xF1\xCF\xD1\x63\xD5\x9B\x6E\xC8\x7D\x32\xD3\x10\x26\xD3\xC1\xD6\xC5\xBD\x53\xD7\xD7\x7A\xC0",
};

			void XmlGetParserBuffer(vl::stream::MemoryStream& stream)
			{
				vl::stream::MemoryStream compressedStream;
				for (vint i = 0; i < parserBufferRows; i++)
				{
					vint size = i == parserBufferRows - 1 ? parserBufferRemain : parserBufferBlock;
					compressedStream.Write((void*)parserBuffer[i], size);
				}
				compressedStream.SeekFromBegin(0);
				vl::stream::LzwDecoder decoder;
				vl::stream::DecoderStream decoderStream(compressedStream, decoder);
				vl::collections::Array<vl::vuint8_t> buffer(65536);
				while (true)
				{
					vl::vint size = decoderStream.Read(&buffer[0], 65536);
					if (size == 0) break;
					stream.Write(&buffer[0], size);
				}
				stream.SeekFromBegin(0);
			}
/***********************************************************************
Unescaping Function Foward Declarations
***********************************************************************/

			extern void XmlMergeTextFragment(vl::collections::List<vl::Ptr<XmlNode>>& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeAttributeValue(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeCData(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeComment(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);

/***********************************************************************
Parsing Tree Conversion Driver Implementation
***********************************************************************/

			class XmlTreeConverter : public vl::parsing::ParsingTreeConverter
			{
			public:
				using vl::parsing::ParsingTreeConverter::SetMember;

				void Fill(vl::Ptr<XmlNode> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
				}

				void Fill(vl::Ptr<XmlText> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->content, obj->GetMember(L"content"), tokens);
				}

				void Fill(vl::Ptr<XmlCData> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeCData(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlAttribute> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					if(SetMember(tree->value, obj->GetMember(L"value"), tokens))
					{
						XmlUnescapeAttributeValue(tree->value, tokens);
					}
				}

				void Fill(vl::Ptr<XmlComment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeComment(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlElement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->closingName, obj->GetMember(L"closingName"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
					if(SetMember(tree->subNodes, obj->GetMember(L"subNodes"), tokens))
					{
						XmlMergeTextFragment(tree->subNodes, tokens);
					}
				}

				void Fill(vl::Ptr<XmlInstruction> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
				}

				void Fill(vl::Ptr<XmlDocument> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->prologs, obj->GetMember(L"prologs"), tokens);
					SetMember(tree->rootElement, obj->GetMember(L"rootElement"), tokens);
				}

				vl::Ptr<vl::parsing::ParsingTreeCustomBase> ConvertClass(vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)override
				{
					if(obj->GetType()==L"Text")
					{
						vl::Ptr<XmlText> tree = new XmlText;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"CData")
					{
						vl::Ptr<XmlCData> tree = new XmlCData;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Attribute")
					{
						vl::Ptr<XmlAttribute> tree = new XmlAttribute;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Comment")
					{
						vl::Ptr<XmlComment> tree = new XmlComment;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Element")
					{
						vl::Ptr<XmlElement> tree = new XmlElement;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Instruction")
					{
						vl::Ptr<XmlInstruction> tree = new XmlInstruction;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Document")
					{
						vl::Ptr<XmlDocument> tree = new XmlDocument;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else 
						return 0;
				}
			};

			vl::Ptr<vl::parsing::ParsingTreeCustomBase> XmlConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				XmlTreeConverter converter;
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> tree;
				converter.SetMember(tree, node, tokens);
				return tree;
			}

/***********************************************************************
Parsing Tree Conversion Implementation
***********************************************************************/

			vl::Ptr<XmlText> XmlText::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlText>();
			}

			vl::Ptr<XmlCData> XmlCData::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlCData>();
			}

			vl::Ptr<XmlAttribute> XmlAttribute::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlAttribute>();
			}

			vl::Ptr<XmlComment> XmlComment::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlComment>();
			}

			vl::Ptr<XmlElement> XmlElement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlElement>();
			}

			vl::Ptr<XmlInstruction> XmlInstruction::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlInstruction>();
			}

			vl::Ptr<XmlDocument> XmlDocument::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlDocument>();
			}

/***********************************************************************
Parser Function
***********************************************************************/

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocumentAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlDocument>();
				}
				return 0;
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocument(input, table, errors, codeIndex);
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElementAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlElement>();
				}
				return 0;
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElement(input, table, errors, codeIndex);
			}

/***********************************************************************
Table Generation
***********************************************************************/

			vl::Ptr<vl::parsing::tabling::ParsingTable> XmlLoadTable()
			{
				vl::stream::MemoryStream stream;
				XmlGetParserBuffer(stream);
				vl::Ptr<vl::parsing::tabling::ParsingTable> table=new vl::parsing::tabling::ParsingTable(stream);
				table->Initialize();
				return table;
			}

		}
	}
}
