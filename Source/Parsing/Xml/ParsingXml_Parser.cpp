#include "ParsingXml_Parser.h"

namespace vl
{
	namespace parsing
	{
		namespace xml
		{
/***********************************************************************
ParserText
***********************************************************************/

const wchar_t parserTextBuffer[] = 
L"\r\n" L""
L"\r\n" L"class Node"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Text : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class CData : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content (XmlUnescapeCData);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Attribute : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"AttName\");"
L"\r\n" L"\ttoken value (XmlUnescapeAttributeValue)\t\t@Color(\"AttValue\");"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Comment : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content (XmlUnescapeComment);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Element : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\ttoken closingName\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\tAttribute[] attributes;"
L"\r\n" L"\tNode[] subNodes (XmlMergeTextFragment);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Instruction : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\tAttribute[] attributes;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Document : Node"
L"\r\n" L"{"
L"\r\n" L"\tNode[] prologs;"
L"\r\n" L"\tElement rootElement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"token INSTRUCTION_OPEN = \"/</?\"\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token INSTRUCTION_CLOSE = \"/?/>\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token COMPLEX_ELEMENT_OPEN = \"/<//\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token SINGLE_ELEMENT_CLOSE = \"///>\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token ELEMENT_OPEN = \"/<\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token ELEMENT_CLOSE = \"/>\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token EQUAL = \"/=\";"
L"\r\n" L""
L"\r\n" L"token NAME = \"[a-zA-Z0-9:._/-]+\"\t\t\t\t\t\t\t\t@ContextColor();"
L"\r\n" L"token ATTVALUE = \"\"\"[^<>\"\"]*\"\"|\'[^<>\']*\'\"\t\t\t\t\t\t@ContextColor();"
L"\r\n" L"token COMMENT = \"/</!--([^/->]|-[^/->]|--[^>])*--/>\"\t\t\t@Color(\"Comment\");"
L"\r\n" L"token CDATA = \"/</!/[CDATA/[([^/]]|/][^/]]|/]/][^>])*/]/]/>\";"
L"\r\n" L"token TEXT = \"([^<>=\"\"\' /r/n/ta-zA-Z0-9:._/-])+|\"\"|\'\";"
L"\r\n" L""
L"\r\n" L"discardtoken SPACE = \"/s+\";"
L"\r\n" L""
L"\r\n" L"rule Attribute XAttribute = NAME:name \"=\" ATTVALUE:value as Attribute;"
L"\r\n" L"rule Text XText = (NAME:content | EQUAL:content | ATTVALUE:content | TEXT:content) as Text;"
L"\r\n" L"rule CData XCData = CDATA:content as CData;"
L"\r\n" L"rule Comment XComment = COMMENT:content as Comment;"
L"\r\n" L"rule Element XElement = \"<\" NAME:name {XAttribute:attributes} (\"/>\" | \">\" {XSubNode:subNodes} \"</\" NAME:closingName \">\") as Element;"
L"\r\n" L"rule Node XSubNode = !XText | !XCData | !XComment | !XElement;"
L"\r\n" L"rule Instruction XInstruction = \"<?\" NAME:name {XAttribute:attributes} \"?>\" as Instruction;"
L"\r\n" L"rule Document XDocument = {XInstruction:prologs | XComment:prologs} XElement:rootElement as Document;"
;

			vl::WString XmlGetParserTextBuffer()
			{
				return parserTextBuffer;
			}

/***********************************************************************
SerializedTable
***********************************************************************/

const vint parserBufferLength = 4424; // 18926 bytes before compressing
const vint parserBufferBlock = 1024;
const vint parserBufferRemain = 328;
const vint parserBufferRows = 5;
const char* parserBuffer[] = {
"\x00\x0E\x00\x02\x83\x80\x07\x7D\x00\x82\x03\xFF\x45\x08\x82\x83\x86\x81\x21\x6F\x6C\x2F\x32\x37\x84\x87\x02\x86\x00\x17\x82\x81\x24\x3C\x3A\x27\x30\x6D\x65\x06\x98\x8A\x80\x8E\x86\x00\x10\x92\x94\x98\x88\x04\x97\x80\x8E\x74\x56\x21\x2C\x35\x3A\x91\x8A\x84\x25\x8C\xA7\x89\x93\x8F\x98\x82\x8D\x08\xC0\x94\x21\x37\x37\x8D\x91\x91\x0C\xB9\x88\x9B\x91\x8D\x9C\x8C\xA0\x3F\x83\x83\xA5\xA0\x96\x98\x93\x93\x04\xCC\xAA\x9E\x93\x80\xA9\xAE\xA9\x44\xC6\x96\xA9\xA8\xAB\x82\xAC\xA7\x0C\xAD\xA9\xA3\x82\x27\x35\x3A\x37\x64\x61\x32\x39\x38\xA0\x9D\xB3\x86\x03\xBC\xAB\x8B\xBC\xB8\x01\xB7\xB7\x71\xF3\xB5\xA4\x8A\xA1\xAD\xBD\xA6\x7B\x88\xAA\xAA\xCC\xB6\xB4\xB8\xB9\x74\xDC\x82\x85\xC6\xB7\xC3\xAC\x97\x7D\xFF\x8F\xC2\xC2\xCD\x83\xBA\x00\x67\x89\xC4\x8B\xC3\xD5\xC4\xC0\xC8\x83\x89\x9F\xC1\xDD\xCC\xD3\x81\xC5\x9A\x81\xD1\xC4\x9C\x00\x8D\xDB\x87\x6F\x6E\x34\x25\x38\x3C\x3A\xBC\x8C\x05\x9D\xFF\x77\xD8\x84\xE0\x88\xDD\xBC\xBE\xC8\xC0\xE9\xD3\xCB\xD4\xCB\x68\xC1\x8F\xA7\xCD\x31\x92\xDC\xD7\x02\x89\x18\x9A\xEB\x8D\x8E\x39\x34\x62\x75\x3B\xDF\x74\xF5\xF0\xF3\xE7\x0F\xC4\x21\x34\x31\x36\xF2\xF2\xAF\x02\xC0\x90\x95\xE5\x32\xDE\xF7\xF2\xD8\x80\x0B\xC4\x2F\x33\x31\x3A\xEB\x74\x37\x74\x78\x7C\x19\x43\x45\x10\x1B\x65\x00\x82\x83\x3F\x0B\x18\x4D\x82\x40\x49\x2E\x13\x1C\x1D\x72\x35\x13\x18\x1D\x69\x39\x6B\x80\x01\x18\x5C\x82\x42\x13\x6F\x24\x12\x4A\x80\x1E\x88\x45\x88\x15\xC9\x4B\x8D\x03\x76\x2C\x9D\x74\x84\x78\xE2\x65\x15\x88\x41\x25\xAE\x15\x54\x70\xDC\x48\x49\x8C\x4C\xDF\x61\x7B\x6C\x7A\x00\x36\x13\x4D\x4D\x9D\x40\x93\x12\x7A\xEC\x44\x80\x53\x18\xB9\x7B\x66\x7E\x80\x4A\x94\x70\x81\x94\x02\x4C\x98\x73\x93\xF7\x79\x7B\x7D\x7F\xFF\x75\x74\x1C\x95\x00\x30\x12\x1D\x53\x67\x33\x1B\x82\x96\x03\x7C\x7E\x7C\x80\x0F\x88\x4D\x9B\x98\x6F\x34\x17\x81\x82\x5E\x8B\x80\x9B\x9C\x00\x8A\x08\x46\x9E\x02\x6B\x7F\x8A\x8F\x65\x26\x90\x97\x74\x02\x78\x9E\x95\x9B\x04\x6D\x93\x1A\x44\x73\x29\x1E\x18\x55\x21\x43\x04\xA2\x74\x85\x88\x80\x83\x8C\x03\x75\x85\x56\x00\x93\x91\x55\xA4\x9D\xD7\x58\x60\x03\x1C\x75\x22\x10\x8A\x88\x82\xB7\x78\xA3\x40\x6D\x91\x83\x85\x85\x17\x99\x8E\x18\x9F\x08\x74\xAE\x9D\x8F\x31\xA9\xAE\x7B\xAA\x02\x6D\xA2\x84\x85\x16\x98\x89\x6C\xA6\x02\x5A\xA1\x48\xB1\x00\x08\xB7\x89\x72\x60\x96\x9E\x91\x80\x02\x90\x08\x45\x0C\x18\x52\xB0\x73\xB5\x38\x4B\x82\x80\xB6\x49\x5A\xB7\x7C\xB7\xD9\x9E\xB6\x78\xB8\x84\x62\xB6\x7A\xB5\x08\x68\xB9\x12\x13\x53\x14\x12\x15\x15\x43\x14\x19\x13\x13\x4E\x1F\x1F\x10\x14\x45\x0E\x1A\xB3\x40\x2F\x3C\x0F\x0B\x0F\xC0\x5F\x61\x04\x46\x03\xD0\x8C\xBA\xBB\xF0\xB2\xB4\xBF\x17\x43\x0C\x1F\x13\x14\x45\x3B\xB2\x43\xBF\x2F\x3E\x0D\x66\x01\x18\x54\x09\xC5\x5E\x4F\x0D\x10\x14\x13\x45\x18\x1F\x15\x11\x20\xCD\x19\xBC\x15\xF6\xB8\xBA\xBD\x87\xFC\xBE\xBF\x08\xA7\x16\x5B\xCC\x42\xC6\x02\x53\x1B\xBB\x11\x20\xE3\xC5\xCB\xC9\x0C\xCE\xC0\xC6\xC4\x00\x2F\x02\xD2\x0F\x92\xBD\x54\x40\x71\x47\xC6\x8B\xCE\x13\x28\xF7\xB9\xBC\xCC\x08\x50\xDD\xBC\xB2\x39\x84\x4B\x88\x43\x57\xC0\x04\xC9\x11\x26\xCC\xDD\xCF\xC3\x45\x10\xD4\x42\xD4\x3E\x1F\x64\xAE\x61\x3A\x46\x81\x15\x15\x41\x0C\x12\xDB\x40\x52\xFD\x08\xC5\xB7\xF7\x40\xDE\x11\x10\x26\xC5\xC8\x42\xDE\x5B\x21\x1D\x0A\x1E\x41\x2D\x0A\x14\x0C\x2D\x39\x0A\x0E\x0B\x5F\x2F\x0D\x09\x17\x2B\x04\x8C\xAE\x7E\xA2\x81\x14\x14\x15\x56\x2D\xD5\x15\x11\x13\x18\x49\xE6\x40\x22\x1B\x1E\x14\x0F\x3E\x22\x0D\x16\x0A\x22\x3C\x17\x0A\xE7\xA0\xE7\x03\xEB\x09\xF9\x48\xDF\x55\xCC\x0F\x5D\xCD\xD4\x15\x22\x18\x45\xEF\xC4\xFE\xA1\x0D\x09\x0B\x28\x1E\xEA\xE2\x0F\x5D\x3C\x1D\x0A\xEF\x2D\x00\xF2\xF3\xF0\x5E\x00\xF9\x0A\x0A\xBB\xD5\xC5\xD7\x40\x59\xE8\xDB\x51\x5E\x44\x12\xE1\x10\x0B\x18\x58\xF8\xEF\x0B\x21\x2F\x0B\x17\x91\xD6\xDE\xFD\xEE\x17\x2F\x1D\x11\xF1\xF9\xBE\xE6\xFC\x1D\xF9\xE8\xC9\xFD\x17\xF2\xEC\xDD\x15\xC7\xD9\x09\x64\x8C\xCA\x40\x54\x21\xC4\x14\x09\x18\x7C\xF2\x43\xF8\xA0\x7D\x06\x08\x27\x00\x05\x17\x32\x0F\x05\x6E\x0F\x04\x7B\x7F\x61\x71\xC1\x45\x77\x70\x89\x6B\x71\x0A\x2B\x0C\x0F\xD2\x67\x07\x71\x0B\x45\x4A\x49\x03\x23\x0A\x28\x01\x0B\x08\x45\x05\x68\x42\x22\x8F\x05\x39\x2B\x06\x75\x93\x22\x40\xB5\x0C\x24\x7E\x81\x34\x50\x0B\x3C\x50\x47\x6E\x34\x68\x20\x1A\xB0\x86\x3B\x32\x85\x0E\x0B\x52\x0F\x0D\x38\x53\x0C\x3D\x72\x14\x0F\x03\x18\x23\x88",
"\x81\x00\x08\x04\x24\x1C\x07\x0D\xFF\x41\x46\x1F\x2D\x80\x00\x2F\x91\x84\xA0\x68\x54\x20\x74\x4B\x88\x57\xBB\x2E\x07\x0F\xF2\x24\x0F\x80\x0C\x26\x8B\x00\x07\x8A\x12\xD2\x8D\x89\x27\x91\x88\x87\x80\x48\x84\x00\x44\x37\x8B\x1C\xAE\x01\x06\x3C\x18\x21\x1C\x82\x23\x8C\x34\x8D\x8A\x07\x20\x17\x6E\xC9\x20\x08\x8E\x1B\x61\x27\x88\x22\x02\x80\x08\x12\x74\x72\xCB\x45\x0C\x8F\x20\x02\x48\x4D\x65\x00\x05\x30\x33\x0B\x90\x76\x9B\x36\x19\x83\x2D\x8D\x34\xB6\x34\x92\x64\x99\x8A\x0C\x73\x88\x20\x4E\xB5\x8C\x89\xBB\x3E\x04\x1E\xFA\x87\x91\x3E\x95\x28\x04\x81\x82\x07\x11\x84\x95\x72\x26\x17\x70\x91\x8A\x95\x25\x23\x8F\x99\x93\x32\x13\x92\x20\x95\x91\x46\x1A\xEC\x85\x96\x17\x33\x04\x93\x04\x3E\x91\x2E\xA1\x93\x94\xBC\x65\x90\x04\x7E\x8C\x91\x2A\x83\x93\x73\x56\xAF\x90\x8F\xB1\x8C\x92\x23\x90\x90\x95\x32\x00\x0F\x96\x00\x03\x99\x19\x12\x08\x22\x6E\xB8\x95\x97\x3C\x91\x4D\x11\x70\x25\x88\x84\x25\x99\x89\xDA\x9E\x04\x08\x40\x0B\x96\x4A\xAE\x50\x58\xB1\x59\x34\x18\x84\x20\x8C\x2C\x2F\x98\x56\xC2\x4E\x0E\x2F\xA4\x18\x22\x7E\xB4\x8E\x9E\xBF\x58\x9E\xAC\x22\x98\x94\x1E\x3F\x02\x04\x79\x86\x98\x22\xC9\x9B\x9D\x3D\x20\x02\x9B\x88\x97\x55\x0E\x8F\x9D\x0E\x54\xBF\x01\x74\xB3\x80\x07\x3D\xC1\x52\x57\x06\x0A\x02\x89\x1B\xB1\x9E\x1B\x04\xA2\x04\x83\x88\xA4\x94\x0B\xB5\x2B\x11\x8E\xA0\xA2\x3C\x92\xA0\x50\x14\xB6\xA0\x46\xD3\x91\xA5\x7C\xA8\x48\x97\x86\x5A\x34\x36\xD8\x09\xA6\x3A\x2E\x04\x06\x0E\x12\x31\x50\xFF\x9D\xA6\x92\xBC\x07\xA4\x0A\xA6\x95\x48\x0D\xAF\xA1\x5A\x91\xA1\x92\x81\x40\x05\x45\xA8\x08\x95\x8A\x48\xA4\x0F\xA8\x98\xA0\x4B\xD3\x05\x55\x53\x4C\x90\x8F\xA4\x46\x55\x88\x51\xA5\xA3\x92\xAF\x00\xA9\x7B\x98\x8F\xA2\x6F\x0D\x51\x47\x62\x29\xAB\x08\xA9\x05\x46\xBD\xAE\xA2\x25\x85\xA8\x8F\x25\xA8\xAF\x31\xC9\x9B\xA5\xA6\x90\xAF\xA9\xD5\x91\xA4\x55\xA2\x06\xAA\x10\x18\xAA\x04\x5A\xAF\xA0\x57\xE2\xA2\x44\x44\xA1\xAE\xAB\x31\xA6\xAE\x5E\x88\x9B\xAD\xB6\x90\x52\x99\x18\xB2\xAF\x34\xBD\xAD\x9C\x5C\xB5\xA2\x56\xF3\x83\x21\x3D\x9F\xB9\x36\x17\x32\x01\x0A\x18\x28\xB7\x3F\xA4\xB3\xA4\xBC\xA6\xA1\xA1\x69\xA8\x9B\x29\xAC\xAE\xA8\x97\x90\xA9\xB2\x17\xA8\xA0\x4D\x81\xAC\xA3\xDC\x00\x0F\xA6\xD9\x9D\xA7\x4E\xBD\xA6\xB4\x43\x18\x26\xB8\x44\xB6\x52\x97\x46\xA3\xB2\xA5\x8C\x94\xB6\x7F\xB6\xB5\x60\xD2\xA0\x05\xC1\x85\xB7\xB0\x89\xB8\x0B\x62\xDE\xAE\xB1\xAE\xA3\xA9\xB2\xFE\x4D\xB8\x08\x15\xBE\x51\xCB\xB0\xA8\x04\x9A\xAF\x91\x4F\xBF\xB2\x54\x9E\x8A\xBA\xA7\x7B\x54\x90\x71\xB3\x03\xA8\x84\x35\xBE\xAE\xEF\xB4\x0C\x73\xB0\xBB\xAF\xD9\xBE\xAD\x9A\x80\xB8\x88\x59\xD5\xB5\xAA\x8C\x98\xBA\x95\x20\x1B\xAA\x77\x8D\xB0\xAD\x05\xC3\xC2\xB2\xFC\xB4\xB0\xA3\x65\xBF\xAC\xC4\xB1\xAB\xAE\xF9\xB5\xAE\x7B\xA0\x5A\xBE\xD7\xA2\xBC\xA1\xD0\xA0\xC2\x74\x82\xC2\xB1\x02\xD7\xAF\xBC\x40\x0A\xC0\x63\xDF\xA0\x05\xC7\x9F\xBC\xBA\x10\xC8\xA6\x5A\x93\xCE\xAD\x53\x96\xC0\xBD\x18\xDC\xC1\x67\xD9\x9C\xB4\x1A\x84\x26\x86\xAC\xBB\x85\x0F\xF2\x40\x2E\xBD\x44\x22\x6F\xE8\x8C\xB6\x3A\xC0\x0F\x79\xEC\x14\x92\x4D\x5D\x5A\x37\xE3\x6D\x48\x0A\x28\xC0\x46\xB4\x60\x18\x21\x96\xFF\x96\xCB\xE5\xB8\x89\xC5\x0F\xAC\xB4\x22\xE2\x44\x4D\x47\x98\xA8\x0B\xF3\x20\x43\x98\xE3\x42\x23\x32\x54\xBB\xC3\x6A\xD8\x8C\x9C\x72\x49\xBF\x8C\x9D\xCA\x37\x4D\xC0\x01\x8E\x55\xCC\x4A\x36\x4E\x47\xC9\x7D\xDE\x4B\x1B\xDB\xC8\x20\x42\xCA\x8F\xCE\x1D\xC9\xC1\x98\xBC\xB2\xA5\x35\xE5\xCE\xB0\x0F\xA9\xCE\x97\x0E\xDD\xCD\x98\xB0\xCB\xD2\x72\xC3\xC9\x4F\xF6\xC1\xD0\xDD\x2C\xBD\x2F\x97\xDA\x34\x15\x83\x26\x8A\xE2\xA1\x9C\xC8\x64\x11\x78\xF4\x03\x28\x9D\xA2\xAB\x98\xB8\xDA\xAE\xC3\x4E\xDB\xB3\xAD\x37\xB5\x00\x23\xB7\xDF\x9C\xAD\xA2\x44\xA1\x10\x18\x08\x45\xBD\x30\xD2\xAF\xC7\x4B\x3D\x30\x02\xD8\xCD\x6F\x14\x3E\x6E\x47\xDB\xBC\x58\xC2\xB9\xBE\x38\xB9\xBE\x0B\x36\x08\xB8\x84\x15\xD8\xBF\x1C\xDB\xBE\x8C\xB2\xBB\xA9\x10\xC2\xC1\xC0\x13\xB4\xBA\x75\x86\xC7\xBC\x15\xDC\xBD\xC1\x2B\xC0\xBF\x59\xC7\x8B\xDA\xF2\xB5\xC3\xA9\x37\xC9\xBC\x08\x3D\xA0\x49\x5F\xCC\x5B\x52\xF6\xDD\x37\x1B\xD8\x08\x22\x7E\xFF\x98\xD8\x89\xCD\xDD\x93\x13\xD8\xAB\x22\x2B\x6D\x6D\x94\xA3\xE3\xB2\xD8\xAC\x94\x43\x89\xE7\x4A\x74\x10\xD1\xFE\x3F\xDF\xE1\x67\x59\xA0\xE0\x40\x13\x6C\x42\x1A\xE8\xCC\x24\x61\x08\xD6\xC4\xCC\x3F\x1B\xA3\x08\x22\x92\xFF\x99\xE4\x61\x04\xA0\xF8\x54\x01\x09\x8A",
"\xD3\xD3\x9A\x28\xFF\xD0\x63\x38\x92\xD2\xF8\xAC\x84\x92\x35\xFE\xA5\x0C\x29\x08\x22\x9E\xE7\xE1\xD9\x00\x4A\xE6\xEC\x27\x6E\xE5\x65\xF0\xE0\xE8\x5E\x52\xE5\x69\x51\xDC\xC3\xE1\x92\xD9\x06\xD5\xC4\x23\xB5\xA1\xD9\xD1\xBC\xAC\xD9\xA9\xDC\xCF\xBB\x7F\xDF\xD3\xC5\x70\xD3\xAE\xC4\x90\xD7\xC6\xB9\xE3\xAD\xBB\x74\xF0\xC1\xBC\x11\xD3\xC4\x5B\x94\xC6\xC7\xCC\xB9\xC0\x40\x3B\xC0\xA3\xAB\x3D\xBE\x0D\xD0\x82\x23\xB4\x8C\xD9\x9F\x1B\xAA\xB8\x20\xBE\xE0\xA1\xEF\x03\xAE\xB7\x41\xD7\xE1\xB6\x10\xDB\xE9\x87\xE0\xD0\xA4\x8C\xB9\xB9\xA2\xD6\xB9\xCB\xCF\x88\xC6\xCB\x40\x7A\x6C\xCF\x35\x42\xD7\xD4\xE3\x84\x0E\xDD\x80\x2C\xD5\x43\xDD\xD2\xBF\xAF\xCD\xBF\xAE\xE5\x03\xD4\x81\x16\x8B\xF4\x42\xC2\x9C\x5C\x2A\xD2\x21\xAC\x68\x9B\xF4\x4B\xCE\xD9\x7E\xCE\xEC\xC2\x17\x37\x01\xEA\x03\x33\xEB\x5D\x85\xAF\xC2\xFF\xAD\xA5\x91\xB7\xA2\xDC\xD8\x87\xCA\xD1\x58\xEB\xC5\xEC\x90\xA7\xEF\x59\xE9\xE3\xBC\x1A\xD7\xB0\x90\x6E\xFB\xB1\x7E\xF5\xD0\xE0\xD6\xC0\x01\x6B\xF9\xDE\xA4\xE6\xF0\x28\x9A\x74\x80\xE3\xC9\x1A\xE4\x20\xC7\xA8\xEB\xF3\x7A\xA8\xE1\xF5\xA8\xD3\xC9\xE7\x9D\xE5\xD9\xD8\xED\xB9\xE7\xA5\xE0\x02\x15\xB9\xE8\xFD\xCC\xD6\xFE\xF5\x4A\x99\xE4\xF8\x98\x23\xFC\x8F\xF1\xFB\xFE\x1E\x78\x7E\x5B\x41\x44\xEA\x76\x44\x48\x49\x7F\x1E\x7E\x03\xE1\x73\x10\xFD\x75\x6C\x71\x77\x7E\x03\x84\x07\xD8\x42\x46\xEC\x7C\x1E\x3E\x01\x77\xAC\x56\x01\x18\x1A\x81\x9E\x50\x78\xA5\x57\x6A\x11\x82\x79\x02\x1A\x37\x47\x49\x64\x1E\x83\x52\x18\x87\x82\xDE\x48\x10\x2B\x82\x77\xF0\x4A\x77\x11\x8F\x7F\x03\x14\x81\x4A\x6F\x78\x80\x66\x79\xBA\x1B\x39\x08\x1A\x83\x95\x71\x65\xDA\x73\x64\x11\x85\x7E\x33\x87\x80\x3D\x81\x74\x36\x88\x4B\x88\x65\x4E\x04\x15\x4E\x45\x82\x68\x11\x87\x7F\x43\x8E\x79\x38\x8A\x5F\x20\x78\x74\xBA\x1B\x82\x04\x1D\x82\xF4\x70\x82\x40\x44\x07\x50\x86\x80\xE8\x4A\x7F\x55\x8A\x6C\x5D\x48\x11\xE6\x76\x85\x3E\x51\x81\x3B\x64\x81\x62\x8D\x5E\x3D\x58\x85\x03\x1D\x82\xA6\x60\x84\x5D\x8F\x85\x61\x44\x84\x45\x52\x7B\x1C\x62\x84\x4C\x77\x65\x6A\x87\x49\x06\x88\x6D\x41\x74\x7D\xC9\x1A\x84\x03\x1C\x84\x00\x72\x80\x5D\x83\x81\x44\x8F\x7D\x84\x8D\x1B\x05\x89\x4D\x89\x81\x81\x47\x87\x87\x4A\x4F\x7D\xB0\x63\x7A\x70\x82\x10\x2D\x88\x7A\x5C\x8C\x45\x76\x85\x82\x4A\x40\x7B\x99\x8E\x60\x7C\x89\x4D\xA8\x7F\x87\x0C\x14\x1C\x14\x80\x7B\x3B\x55\x4B\x71\x7D\x4B\x34\x00\x4C\x03\x12\x4C\xB5\x44\x50\xDB\x6C\x50\xCB\x4D\x70\xAE\x47\x4C\xD1\x49\x51\xB5\x49\x71\xFC\x78\x73\x1E\x70\x72\x01\x82\x03\x26\x78\x10\xC9\x88\x80\xED\x78\x47\x2B\x7D\x72\x6A\x5A\x70\x11\x70\x73\x1E\x7C\x4E\x80\x8C\x63\x27\x87\x8A\x2E\x82\x50\xA5\x54\x03\x7C\x74\x10\x7E\x7B\x8D\x74\x76\x54\x07\x5C\x7C\x86\x7F\x7B\x2F\x59\x2B\x8B\x73\x53\x8F\x4C\x5A\x4C\x6D\x22\xD9\x48\x68\x91\x8D\x84\xBA\x1E\x4B\x84\x64\x10\x86\x64\x8F\x89\x6C\x52\x62\x68\x47\x64\x65\x69\x90\x68\x6C\x64\x84\x69\x6F\x0E\x66\x15\x54\x75\x88\x43\x67\x9B\x63\x4D\x88\x6A\x74\xAF\x18\x73\x68\x8B\x53\xF4\x72\x03\x3E\x78\x10\x15\x99\x7F\x68\x82\x74\x4D\x03\x3B\x45\x73\x8D\x8F\x49\x73\x0E\x92\x10\x8B\x14\x75\xB4\x77\x65\x35\x08\x7B\x02\x1A\x7B\xF9\x5A\x6D\x58\x77\x8E\xB5\x50\x7C\xD3\x5F\x75\x84\x54\x6E\x62\x7A\x58\x0E\x68\x7C\x2F\x65\x56\x68\x7D\x6E\xCE\x75\x61\xD1\x7A\x5E\xF9\x50\x04\x8F\x8F\x25\xF8\x69\x88\x32\x0E\x6F\x08\x18\x94\x97\x89\x1C\xB8\x88\x75\xCE\x24\x70\xF3\x67\x70\x4C\x0D\x91\x90\x6C\x8B\xCF\x43\x5E\xD2\x82\x71\xFA\x34\x95\xD3\x48\x71\xF9\x1F\x8A\x50\x55\x89\xB5\x44\x2E\xF5\x37\x1F\x0B\x82\x10\x0D\x8C\x1E\x46\x2E\x71\xC0\x1C\x01\x24\x12\x20\x29\x83\x77\x22\x51\x89\xAC\x50\x1C\x1E\x0F\x96\xF7\x15\x89\xFA\x80\x5C\x88\x60\x1C\x20\x08\x97\xEE\x13\x86\x53\x23\x29\x39\x70\x1C\xB7\x31\x2E\x81\x9E\x86\xF9\x57\x27\xF9\x50\x1C\xFE\x38\x98\xE6\x13\x94\x40\x30\x70\xC0\x16\x02\x80\x96\x1E\xA5\x8B\x62\x76\x33\x56\xC0\x18\x02\x97\x95\x1E\x10\x02\x42\x09\x12\x1C\xC0\x1D\x19\x64\x97\x9A\xA8\x98\x13\xC2\x1F\x38\x6F\x39\x9A\x00\x0D\x19\xA6\x97\x3F\x26\x23\x10\xC9\x40\x1C\x60\x95\x4D\x64\x9D\x1C\x05\x1F\x44\xA2\x9E\x9A\xBE\x94\x12\xC2\x1A\x46\xC8\x28\x9A\xB0\x97\x9A\x40\x21\x4D\xB6\x90\x6D\xD9\x43\x96\xA3\x90\x9C\x1B\x4F\x9B\x02\x11\x9B\x64\x92\x96\x50\x59\x9C\x37\x7F\x4D\x50\x5F\x0F\xAD\x95\x10\xDB\x94\x20\xA5\x9D\x29\x03\x1D\x9B\xAE\x94\x9D\xB8\x9A\x9C\x04\x17\x46\xD5\x47\x96",
"\x05\x20\x9D\x50\x4A\x9C\xDA\x4B\x9D\xD6\x95\x2B\x03\x19\x8E\xBB\x13\x07\xC0\x1A\x87\x0A\x2B\x9D\xEA\x9F\x9D\x0C\x1A\x9E\xE2\x99\x9A\xE4\x92\x60\xF1\x97\x9E\x98\x40\x55\xEA\x9B\x9F\xA7\x97\x9B\x02\x60\x9F\xE6\x93\x10\xB6\x27\x5B\xC0\x11\x97\x2F\x82\x2B\xEC\x90\x2E\xBA\x94\x19\x22\x95\xA1\xE4\x27\xA1\xAC\x95\xA1\xDB\x9F\x19\x08\xA4\x96\x12\xAC\x8D\x6E\x02\x9D\xB3\x9C\x10\xC6\x25\x06\x03\xAE\xA0\x05\xA5\x9E\xD7\x27\xA1\x04\x29\x67\x1A\xA1\x1C\x24\x19\x67\x4F\x43\xA3\x1C\xA8\x11\x0C\xA4\x96\x1F\xA0\x9E\xAE\x98\x9F\x5E\x26\xA2\x34\x22\x9B\xB5\x9D\xA0\x2E\x4D\xA2\x02\xA4\x18\xC2\x1D\x19\x8F\x34\x9C\x15\xA4\x97\x27\x81\xA1\xD7\x82\x8E\x22\x5A\x9D\x24\x1B\x9D\x6A\x4C\x9F\x08\x11\x02\x18\x1F\x9F\xA8\x90\xA5\x72\x99\x4F\x52\xAB\x8A\xEE\x47\x82\xEA\x9C\xA5\xEC\x93\xA2\x74\x7B\xA3\x94\x2D\xA6\xFF\x85\x90\xF6\x90\x8F\x04\x10\x79\x9F\x76\xA5\x64\xA4\x96\x9D\x1A\x46\x5E\xA7\x9A\x60\xA3\xA1\xB9\x13\xA6\xC5\x15\xA6\x61\xA2\x2B\xEA\x99\xA5\xA7\x9A\xA6\x22\x5C\xA6\x9E\x2E\xA6\x6C\x60\xA7\x38\x20\x8F\xFA\x89\x9B\x4B\xA6\x86\x15\xA2\xA4\xDC\x2C\x98\x1C\x67\x9F\x8A\x9C\x61\xFF\x0F\x9F\x76\xA6\x4E\xA7\x9D\x19\x15\x94\x10\x7B\xA4\x96\x98\xA0\x20\x9A\xA0\x6A\x3D\x5A\x9E\xA3\xAE\x9B\x40\xAA\x1B\xA5\xA0\x9D\x99\x9E\x55\x9F\xA6\x35\xA1\xA8\x11\x68\xA3\x42\x15\xA7\xAA\x5E\x29\xAA\x33\x71\x5C\xF9\x57\xA6\x15\xAF\xAA\x74\x06\xA9\xBD\x2F\x67\x02\x1A\x90\x8D\x92\xA7\x03\x14\xA7\x53\x85\xAB\xAB\x68\xA7\xD7\x84\xAA\xBB\xA3\x29\x3D\x5E\xAB\x4B\x70\xAC\x1C\x65\xA8\xC3\xAB\xA9\x00\x26\xAC\x00\x01\x89\xCA\xA9\xA9\xCC\xAE\x64\x48\x8F\x79\xBE\x97\xA1\xEA\x91\x7F\x38\xA2\x1C\xF9\x1E\x63\xBE\x9D\xA3\xD7\x92\xAB\xDE\xAE\x25\x9F\x1D\xAA\x3F\xA2\x7A\x0E\x64\xA3\x49\x1F\x44\x22\x89\x9A\xFF\x96\x36\xDD\xAA\xAA\xD3\x7D\x73\x03\xBF\xAB\xC6\x7E\x55\xE0\xAD\x2C\xD2\x81\x30\xCF\x92\x89\x29\x2B\x9A\x04\x35\xA1\x01\xB6\xA4\xA9\x94\xAC\xF7\xA7\xB0\xD9\xA9\xB0\x63\x5B\xB0\x93\x2F\x94\xBA\x1E\xB0\x69\x38\x4B\x00\x77\xA1\x6A\x4F\xAF\xA8\x95\xB1\xF3\xAF\x9B\x18\xB6\xB0\xEC\x93\xAB\x1D\xB7\x9A\x0C\xB0\x71\x22\xB3\x3D\x24\xB1\xB1\x24\x16\x7D\x3A\x8F\x9B\x2A\xB2\x9F\x2F\xB5\xAF\xBA\x19\xB1\x3F\xB0\x6A\xA3\x7E\xB1\xB0\x30\x00\x20\xB4\x07\xD8\xAF\x90\x34\x78\x86\x17\xAB\x79\x9B\x80\xB0\x0F\xB4\xA0\x43\xB8\xB0\xF4\x6E\xB2\xF4\xA4\xB4\x0E\x66\xB4\x6D\xA9\xB4\xC0\x17\xA0\xC4\x85\x6C\x17\xA6\x88\x23\x84\xB1\x53\xBC\xA2\x55\xBB\xB1\x57\xBC\x10\xF8\xA7\xB1\xFA\xAB\x62\x5C\xBB\xA8\x5E\xB7\xB6\x78\x17\xB3\xBD\x1F\x9B\x17\xA8\x2C\x15\x05\xA9\x74\xBB\x46\x15\xAA\x97\x7D\x93\x19\xEE\xA2\x33\xD0\x9A\x41\x77\xA0\x9D\x80\xB8\xAE\xCD\x99\x14\x3A\xBE\xA1\x7D\xB6\xA8\xD3\x90\xA9\x88\x61\xB7\xAF\x38\xB4\x0D\xB2\x2A\x1B\xB5\x98\x82\xBE\x9C\x0C\x1C\x81\x85\xBA\xB1\x4C\xB0\x00\x81\xBC\x10\x89\xB3\x85\x33\xA9\x14\x93\xAC\x10\x17\x07\xBA\xAA\x97\xA5\x16\xBA\xA5\x54\xB1\x35\xC3\x8B\xB2\xAE\xAF\xB6\x5E\x5A\xA8\xA1\xB9\xAD\x2E\x68\x2A\x4B\xB9\xA1\x7D\x8D\xAB\x15\xA9\xA3\x0C\x18\x01\x7C\xBC\x10\xE0\xA1\x89\xEE\x67\x59\xBD\xB0\x39\xBF\xB1\xB2\x4A\xAC\xB9\x08\x19\x01\xC5\xB0\x9D\x93\x99\x1C\x35\xB2\x3D\xD9\x77\xA1\xDB\x94\xB6\xD7\x22\xAA\x5D\xA5\xA1\xD5\xB7\xB7\x7D\xB7\x12\xD9\x7C\xAA\x15\xA3\x94\xB1\xAC\xB2\xB6\xBC\x99\x1B\xA9\xBA\x08\x1A\x01\xD3\xBF\x9B\x6B\x95\x6C\x5F\xB3\xBB\xD9\x48\x72\xDA\xB4\x44\xB7\xAC\xB6\xDF\xBC\x9E\xF3\xBC\x1E\xF5\xBD\x9F\x61\xBC\x1E\xE6\xBC\x9E\x60\xB4\x73\x1E\x79\xBE\xB5\xBA\xB5\x2B\x62\xA9\xD0\xB4\x10\x1B\x01\xBF\xBE\x90\x26\x9A\xB6\x34\xA1\xB2\x90\x0A\x2E\xA9\xDB\xBB\xBF\x16\x9D\xBF\xD0\x94\xC1\x68\x8B\xBC\x23\x99\x73\x05\xC9\xB5\x08\xB9\x73\x0A\xC9\xAF\x0C\xC4\xAB\x58\xAC\xC1\x04\x19\xAB\xD4\xAC\x9E\x20\xC4\x86\x22\xC0\x91\x64\x82\xAC\x69\xB7\xC1\x39\x78\xBB\xF1\x13\x29\x6F\xA5\x26\x8F\xA4\xBA\x37\x8E\x83\xD0\xA2\x10\x90\xB8\x10\x79\xAE\xC1\xBF\x93\xC3\xA8\xA8\xB9\x3A\xC8\x86\xDC\xA9\xC3\xBE\xB7\xBF\x68\x8C\xC3\xEB\x9C\xA8\x65\x61\xC4\x3A\x23\xC4\x4D\xCC\x9E\xC2\xBD\xA6\xBF\x95\x9C\x64\x90\x34\x45\xA6\xC1\x53\xC4\x75\xA7\x9F\xC5\xE2\x72\xC1\xD1\x97\x9A\x64\xC7\x23\xD3\xA3\x10\x6C\x45\x97\xAC\xB9\x9A\x17\xA5\x89\x75\xC9\xC7\xED\xA4\x12\xC0\x1D\x01\x7A\xCA\xC7\x4F\xBD\x4D\x6C\xCF\x9A\x32\xBF\xB1\x97\xB2\xC0\x88\xC7\xBF\x6C\x97\xA1\xC0\x1F\x01\x7F\xC9\xAE\xC2\x1A\xB7\x8F\xC8\x2D\x8C",
"\xC8\xAB\x93\xC6\xC7\x91\xC8\x11\x7B\xBC\x9E\x86\xBB\xA5\x7F\xB2\xB9\x8A\xBC\xAF\x38\x1F\xAE\x83\xCF\x19\x30\xCE\x9B\xA5\xBE\x83\xCF\xBC\xB8\x9A\x3E\xB8\x23\xBE\xC9\xEC\x99\xCA\xDF\xA5\xC8\x47\xB3\xB7\x66\xCC\xBC\x54\xC4\xC3\xA2\xC4\x18\xC0\x19\x8C\x97\xCE\xC5\xC2\x1D\xB8\x9C\xC8\x11\x94\xBD\xC3\x55\x27\xC8\xBF\xA9\xB9\x21\xCB\xCB\x09\x10\x1C\x25\x0F\xCB\x90\xC4\x12\xA4\xC0\xCD\xCC\xC3\x19\xC0\x17\x02\xD4\xC1\xCD\xFD\xA3\xB1\xC3\xC6\xBC\xB4\xCD\xB5\xC8\xC2\x3D\xD8\xB5\xB2\x12\xBC\x10\x28\xBE\xC2\x03\x15\xCC\x57\xC6\xCB\x36\xBD\xCE\xD9\xB1\x9C\xDC\xCF\xB9\xDE\xC6\xAA\x86\xC4\xB3\xE3\xB4\x49\x94\x95\xCD\x05\x1C\xBD\xE7\xC2\xAD\xF3\xC4\x2E\x33\xBF\x2C\xD7\xB5\x19\x76\xB1\x20\xA4\x98\xB5\xD9\xCD\xBE\xD2\xC4\xB8\x61\xCD\xB7\x6D\xB8\x9A\x30\xB2\x22\xFA\xCF\x0F\xFE\xAE\xCA\xED\xC4\x10\x0F\xD7\x9A\x11\xD5\x06\xEA\xCB\x24\xE1\xC4\xD0\xEE\xC4\xCE\x24\x1F\x38\xFD\xC4\x2E\xF2\xAD\xC1\x52\xC8\xCB\x1C\xB2\x22\x1D\xD3\x10\xEC\xC2\xCE\x20\xDF\xCE\xB4\x11\xCF\xBF\x97\xD2\x18\xD0\xBA\x67\xC5\xB4\xDF\xC2\xB7\x1F\xD5\xB7\x21\xD8\xB3\xAC\xCC\x10\x3B\xB1\xAF\x0E\xD8\xD3\x2A\xDA\xD3\xF4\xC5\xCB\x3D\xD8\xCB\xCA\xC4\x86\x81\xCC\x10\x51\xB8\x9A\x36\xD3\x10\x19\xD4\x96\x1B\xDD\xD2\xC7\xC6\xCF\x89\xCB\xC6\x08\xC2\xB6\xC2\x1C\xCF\x16\xD0\xD3\x02\x15\xD5\xE4\x27\xD5\x3B\xD5\xB9\x2F\xD0\xD2\xE3\xC6\xBD\x09\xDD\xD6\x8F\xC0",
};

			void XmlGetParserBuffer(vl::stream::MemoryStream& stream)
			{
				vl::stream::MemoryStream compressedStream;
				for (vint i = 0; i < parserBufferRows; i++)
				{
					vint size = i == parserBufferRows - 1 ? parserBufferRemain : parserBufferBlock;
					compressedStream.Write((void*)parserBuffer[i], size);
				}
				compressedStream.SeekFromBegin(0);
				vl::stream::LzwDecoder decoder;
				vl::stream::DecoderStream decoderStream(compressedStream, decoder);
				vl::collections::Array<vl::vuint8_t> buffer(65536);
				while (true)
				{
					vl::vint size = decoderStream.Read(&buffer[0], 65536);
					if (size == 0) break;
					stream.Write(&buffer[0], size);
				}
				stream.SeekFromBegin(0);
			}
/***********************************************************************
Unescaping Function Foward Declarations
***********************************************************************/

			extern void XmlMergeTextFragment(vl::collections::List<vl::Ptr<XmlNode>>& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeAttributeValue(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeCData(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeComment(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);

/***********************************************************************
Parsing Tree Conversion Driver Implementation
***********************************************************************/

			class XmlTreeConverter : public vl::parsing::ParsingTreeConverter
			{
			public:
				using vl::parsing::ParsingTreeConverter::SetMember;

				void Fill(vl::Ptr<XmlNode> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
				}

				void Fill(vl::Ptr<XmlText> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->content, obj->GetMember(L"content"), tokens);
				}

				void Fill(vl::Ptr<XmlCData> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeCData(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlAttribute> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					if(SetMember(tree->value, obj->GetMember(L"value"), tokens))
					{
						XmlUnescapeAttributeValue(tree->value, tokens);
					}
				}

				void Fill(vl::Ptr<XmlComment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeComment(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlElement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->closingName, obj->GetMember(L"closingName"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
					if(SetMember(tree->subNodes, obj->GetMember(L"subNodes"), tokens))
					{
						XmlMergeTextFragment(tree->subNodes, tokens);
					}
				}

				void Fill(vl::Ptr<XmlInstruction> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
				}

				void Fill(vl::Ptr<XmlDocument> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->prologs, obj->GetMember(L"prologs"), tokens);
					SetMember(tree->rootElement, obj->GetMember(L"rootElement"), tokens);
				}

				vl::Ptr<vl::parsing::ParsingTreeCustomBase> ConvertClass(vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)override
				{
					if(obj->GetType()==L"Text")
					{
						vl::Ptr<XmlText> tree = new XmlText;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"CData")
					{
						vl::Ptr<XmlCData> tree = new XmlCData;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Attribute")
					{
						vl::Ptr<XmlAttribute> tree = new XmlAttribute;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Comment")
					{
						vl::Ptr<XmlComment> tree = new XmlComment;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Element")
					{
						vl::Ptr<XmlElement> tree = new XmlElement;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Instruction")
					{
						vl::Ptr<XmlInstruction> tree = new XmlInstruction;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Document")
					{
						vl::Ptr<XmlDocument> tree = new XmlDocument;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else 
						return 0;
				}
			};

			vl::Ptr<vl::parsing::ParsingTreeCustomBase> XmlConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				XmlTreeConverter converter;
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> tree;
				converter.SetMember(tree, node, tokens);
				return tree;
			}

/***********************************************************************
Parsing Tree Conversion Implementation
***********************************************************************/

			vl::Ptr<XmlText> XmlText::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlText>();
			}

			vl::Ptr<XmlCData> XmlCData::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlCData>();
			}

			vl::Ptr<XmlAttribute> XmlAttribute::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlAttribute>();
			}

			vl::Ptr<XmlComment> XmlComment::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlComment>();
			}

			vl::Ptr<XmlElement> XmlElement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlElement>();
			}

			vl::Ptr<XmlInstruction> XmlInstruction::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlInstruction>();
			}

			vl::Ptr<XmlDocument> XmlDocument::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlDocument>();
			}

/***********************************************************************
Visitor Pattern Implementation
***********************************************************************/

			void XmlText::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlCData::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlAttribute::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlComment::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlElement::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlInstruction::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlDocument::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

/***********************************************************************
Parser Function
***********************************************************************/

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocumentAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlDocument>();
				}
				return 0;
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocument(input, table, errors, codeIndex);
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElementAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlElement>();
				}
				return 0;
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElement(input, table, errors, codeIndex);
			}

/***********************************************************************
Table Generation
***********************************************************************/

			vl::Ptr<vl::parsing::tabling::ParsingTable> XmlLoadTable()
			{
				vl::stream::MemoryStream stream;
				XmlGetParserBuffer(stream);
				vl::Ptr<vl::parsing::tabling::ParsingTable> table=new vl::parsing::tabling::ParsingTable(stream);
				table->Initialize();
				return table;
			}

		}
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			using namespace vl::parsing::xml;

#define PARSING_TOKEN_FIELD(NAME)\
			CLASS_MEMBER_EXTERNALMETHOD_INVOKETEMPLATE(get_##NAME, NO_PARAMETER, vl::WString(ClassType::*)(), [](ClassType* node) { return node->NAME.value; }, L"*")\
			CLASS_MEMBER_EXTERNALMETHOD_INVOKETEMPLATE(set_##NAME, { L"value" }, void(ClassType::*)(const vl::WString&), [](ClassType* node, const vl::WString& value) { node->NAME.value = value; }, L"*")\
			CLASS_MEMBER_PROPERTY_REFERENCETEMPLATE(NAME, get_##NAME, set_##NAME, L"$This->$Name.value")\

			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlNode, system::XmlNode)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlText, system::XmlText)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlCData, system::XmlCData)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlAttribute, system::XmlAttribute)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlComment, system::XmlComment)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlElement, system::XmlElement)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlInstruction, system::XmlInstruction)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlDocument, system::XmlDocument)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlNode::IVisitor, system::XmlNode::IVisitor)

			BEGIN_CLASS_MEMBER(XmlNode)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})
			END_CLASS_MEMBER(XmlNode)

			BEGIN_CLASS_MEMBER(XmlText)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlText>(), NO_PARAMETER)

				PARSING_TOKEN_FIELD(content)
			END_CLASS_MEMBER(XmlText)

			BEGIN_CLASS_MEMBER(XmlCData)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlCData>(), NO_PARAMETER)

				PARSING_TOKEN_FIELD(content)
			END_CLASS_MEMBER(XmlCData)

			BEGIN_CLASS_MEMBER(XmlAttribute)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlAttribute>(), NO_PARAMETER)

				PARSING_TOKEN_FIELD(name)
				PARSING_TOKEN_FIELD(value)
			END_CLASS_MEMBER(XmlAttribute)

			BEGIN_CLASS_MEMBER(XmlComment)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlComment>(), NO_PARAMETER)

				PARSING_TOKEN_FIELD(content)
			END_CLASS_MEMBER(XmlComment)

			BEGIN_CLASS_MEMBER(XmlElement)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlElement>(), NO_PARAMETER)

				PARSING_TOKEN_FIELD(name)
				PARSING_TOKEN_FIELD(closingName)
				CLASS_MEMBER_FIELD(attributes)
				CLASS_MEMBER_FIELD(subNodes)
			END_CLASS_MEMBER(XmlElement)

			BEGIN_CLASS_MEMBER(XmlInstruction)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlInstruction>(), NO_PARAMETER)

				PARSING_TOKEN_FIELD(name)
				CLASS_MEMBER_FIELD(attributes)
			END_CLASS_MEMBER(XmlInstruction)

			BEGIN_CLASS_MEMBER(XmlDocument)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlDocument>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(prologs)
				CLASS_MEMBER_FIELD(rootElement)
			END_CLASS_MEMBER(XmlDocument)

			BEGIN_INTERFACE_MEMBER(XmlNode::IVisitor)
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlText* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlCData* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlAttribute* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlComment* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlElement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlInstruction* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlDocument* node))
			END_INTERFACE_MEMBER(XmlNode)

#undef PARSING_TOKEN_FIELD

			class XmlTypeLoader : public vl::Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					ADD_TYPE_INFO(vl::parsing::xml::XmlNode)
					ADD_TYPE_INFO(vl::parsing::xml::XmlText)
					ADD_TYPE_INFO(vl::parsing::xml::XmlCData)
					ADD_TYPE_INFO(vl::parsing::xml::XmlAttribute)
					ADD_TYPE_INFO(vl::parsing::xml::XmlComment)
					ADD_TYPE_INFO(vl::parsing::xml::XmlElement)
					ADD_TYPE_INFO(vl::parsing::xml::XmlInstruction)
					ADD_TYPE_INFO(vl::parsing::xml::XmlDocument)
					ADD_TYPE_INFO(vl::parsing::xml::XmlNode::IVisitor)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};
#endif

			bool XmlLoadTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new XmlTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}
