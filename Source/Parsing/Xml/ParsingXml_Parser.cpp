/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::ParsingXml.parser.txt

This file is generated by: Vczh Parser Generator
***********************************************************************/

#include "../Parsing.h"
#include "../ParsingDefinitions.h"
#include "../ParsingAutomaton.h"
#include "ParsingXml_Parser.h"

namespace vl
{
	namespace parsing
	{
		namespace xml
		{
/***********************************************************************
ParserText
***********************************************************************/

const wchar_t parserTextBuffer[] = 
L"\r\n" L""
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L"// AST"
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L""
L"\r\n" L"class Node"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Text : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class CData : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content (XmlUnescapeCData);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Attribute : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"AttName\");"
L"\r\n" L"\ttoken value (XmlUnescapeAttributeValue)\t\t@Color(\"AttValue\");"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Comment : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content (XmlUnescapeComment);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Element : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\ttoken closingName\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\tAttribute[] attributes;"
L"\r\n" L"\tNode[] subNodes (XmlMergeTextFragment);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Instruction : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\tAttribute[] attributes;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Document : Node"
L"\r\n" L"{"
L"\r\n" L"\tNode[] prologs;"
L"\r\n" L"\tElement rootElement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L"// Lexer"
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L""
L"\r\n" L"token INSTRUCTION_OPEN = \"/</?\"\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token INSTRUCTION_CLOSE = \"/?/>\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token COMPLEX_ELEMENT_OPEN = \"/<//\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token SINGLE_ELEMENT_CLOSE = \"///>\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token ELEMENT_OPEN = \"/<\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token ELEMENT_CLOSE = \"/>\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token EQUAL = \"/=\";"
L"\r\n" L""
L"\r\n" L"token NAME = \"[a-zA-Z0-9:._/-]+\"\t\t\t\t\t\t\t\t@ContextColor();"
L"\r\n" L"token ATTVALUE = \"\"\"[^<>\"\"]*\"\"|\'[^<>\']*\'\"\t\t\t\t\t\t@ContextColor();"
L"\r\n" L"token COMMENT = \"/</!--([^/->]|-[^/->]|--[^>])*--/>\"\t\t\t@Color(\"Comment\");"
L"\r\n" L"token CDATA = \"/</!/[CDATA/[([^/]]|/][^/]]|/]/][^>])*/]/]/>\";"
L"\r\n" L"token TEXT = \"([^<>=\"\"\' /r/n/ta-zA-Z0-9:._/-])+|\"\"|\'\";"
L"\r\n" L""
L"\r\n" L"discardtoken SPACE = \"/s+\";"
L"\r\n" L""
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L"// Rules"
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L""
L"\r\n" L"rule Attribute XAttribute = NAME:name \"=\" ATTVALUE:value as Attribute;"
L"\r\n" L"rule Text XText = (NAME:content | EQUAL:content | ATTVALUE:content | TEXT:content) as Text;"
L"\r\n" L"rule CData XCData = CDATA:content as CData;"
L"\r\n" L"rule Comment XComment = COMMENT:content as Comment;"
L"\r\n" L"rule Element XElement = \"<\" NAME:name {XAttribute:attributes} (\"/>\" | \">\" {XSubNode:subNodes} \"</\" NAME:closingName \">\") as Element;"
L"\r\n" L"rule Node XSubNode = !XText | !XCData | !XComment | !XElement;"
L"\r\n" L"rule Instruction XInstruction = \"<?\" NAME:name {XAttribute:attributes} \"?>\" as Instruction;"
L"\r\n" L"rule Document XDocument = {XInstruction:prologs | XComment:prologs} XElement:rootElement as Document;"
;

			vl::WString XmlGetParserTextBuffer()
			{
				return parserTextBuffer;
			}

/***********************************************************************
SerializedTable
***********************************************************************/

const vint parserBufferLength = 4449; // 18926 bytes before compressing
const vint parserBufferBlock = 1024;
const vint parserBufferRemain = 353;
const vint parserBufferRows = 5;
const char* parserBuffer[] = {
"\x00\x0E\x00\x02\x83\x80\x07\x7D\x00\x82\x03\xFF\x45\x08\x82\x83\x86\x81\x21\x6F\x6C\x2F\x32\x37\x84\x87\x02\x86\x00\x17\x82\x81\x24\x3C\x3A\x27\x30\x6D\x65\x06\x98\x8A\x80\x8E\x86\x00\x10\x92\x94\x98\x88\x04\x97\x80\x8E\x74\x56\x21\x2C\x35\x3A\x91\x8A\x84\x25\x8C\xA7\x89\x93\x8F\x98\x82\x8D\x08\xC0\x94\x21\x37\x37\x8D\x91\x91\x0C\xB9\x88\x9B\x91\x8D\x9C\x8C\xA0\x3F\x83\x83\xA5\xA0\x96\x98\x93\x93\x04\xCC\xAA\x9E\x93\x80\xA9\xAE\xA9\x44\xC6\x96\xA9\xA8\xAB\x82\xAC\xA7\x0C\xAD\xA9\xA3\x82\x27\x35\x3A\x37\x64\x61\x32\x39\x38\xA0\x9D\xB3\x86\x03\xBC\xAB\x8B\xBC\xB8\x01\xB7\xB7\x71\xF3\xB5\xA4\x8A\xA1\xAD\xBD\xA6\x7B\x88\xAA\xAA\xCC\xB6\xB4\xB8\xB9\x74\xDC\x82\x85\xC6\xB7\xC3\xAC\x97\x7D\xFF\x8F\xC2\xC2\xCD\x83\xBA\x00\x67\x89\xC4\x8B\xC3\xD5\xC4\xC0\xC8\x83\x89\x9F\xC1\xDD\xCC\xD3\x81\xC5\x9A\x81\xD1\xC4\x9C\x00\x8D\xDB\x87\x6F\x6E\x34\x25\x38\x3C\x3A\xBC\x8C\x05\x9D\xFF\x77\xD8\x84\xE0\x88\xDD\xBC\xBE\xC8\xC0\xE9\xD3\xCB\xD4\xCB\x68\xC1\x8F\xA7\xCD\x31\x92\xDC\xD7\x02\x89\x18\x9A\xEB\x8D\x8E\x39\x34\x62\x75\x3B\xDF\x74\xF5\xF0\xF3\xE7\x0F\xC4\x21\x34\x31\x36\xF2\xF2\xAF\x02\xC0\x90\x95\xE5\x32\xDE\xF7\xF2\xD8\x80\x0B\xC4\x2F\x33\x31\x3A\xEB\x74\x37\x74\x78\x7C\x19\x43\x45\x10\x1B\x65\x00\x82\x83\x3F\x0B\x18\x4D\x82\x40\x49\x2E\x13\x1C\x1D\x72\x35\x13\x18\x1D\x69\x39\x6B\x80\x01\x18\x5C\x82\x42\x13\x6F\x24\x12\x4A\x80\x1E\x88\x45\x88\x15\xC9\x4B\x8D\x03\x76\x2C\x9D\x74\x84\x78\xE2\x65\x15\x88\x41\x25\xAE\x15\x54\x70\xDC\x48\x49\x8C\x4C\xDF\x61\x7B\x6C\x7A\x00\x36\x13\x4D\x4D\x9D\x40\x93\x12\x7A\xEC\x44\x80\x53\x18\xB9\x7B\x66\x7E\x80\x4A\x94\x70\x81\x94\x02\x4C\x98\x73\x93\xF7\x79\x7B\x7D\x7F\xFF\x75\x74\x1C\x95\x00\x30\x12\x1D\x53\x67\x33\x1B\x82\x96\x03\x7C\x7E\x7C\x80\x0F\x88\x4D\x9B\x98\x6F\x34\x17\x81\x82\x5E\x8B\x80\x9B\x9C\x00\x8A\x08\x46\x9E\x02\x6B\x7F\x8A\x8F\x65\x26\x90\x97\x74\x02\x78\x9E\x95\x9B\x04\x6D\x93\x1A\x44\x73\x29\x1E\x18\x55\x21\x43\x04\xA2\x74\x85\x88\x80\x83\x8C\x03\x75\x85\x56\x00\x93\x91\x55\xA4\x9D\xD7\x58\x60\x03\x1C\x75\x22\x10\x8A\x88\x82\xB7\x78\xA3\x40\x6D\x91\x83\x85\x85\x17\x99\x8E\x18\x9F\x08\x74\xAE\x9D\x8F\x31\xA9\xAE\x7B\xAA\x02\x6D\xA2\x84\x85\x16\x98\x89\x6C\xA6\x02\x5A\xA1\x48\xB1\x00\x08\xB7\x89\x72\x60\x96\x9E\x91\x80\x02\x90\x08\x45\x0C\x18\x52\xB0\x73\xB5\x38\x4B\x82\x80\xB6\x49\x5A\xB7\x7C\xB7\xD9\x9E\xB6\x78\xB8\x84\x62\xB6\x7A\xB5\x08\x68\xB9\x12\x13\x53\x14\x12\x15\x15\x43\x14\x19\x13\x13\x4E\x1F\x1F\x10\x14\x45\x0E\x1A\xB3\x40\x2F\x3C\x0F\x0B\x0F\xC0\x5F\x61\x04\x46\x03\xD0\x8C\xBA\xBB\xF0\xB2\xB4\xBF\x17\x43\x0C\x1F\x13\x14\x45\x3B\xB2\x43\xBF\x2F\x3E\x0D\x66\x01\x18\x54\x09\xC5\x5E\x4F\x0D\x10\x14\x13\x45\x18\x1F\x15\x11\x20\xCD\x19\xBC\x15\xF6\xB8\xBA\xBD\x87\xFC\xBE\xBF\x08\xA7\x16\x5B\xCC\x42\xC6\x02\x53\x1B\xBB\x11\x20\xE3\xC5\xCB\xC9\x0C\xCE\xC0\xC6\xC4\x00\x2F\x02\xD2\x0F\x92\xBD\x54\x40\x71\x47\xC6\x8B\xCE\x13\x28\xF7\xB9\xBC\xCC\x08\x50\xDD\xBC\xB2\x39\x84\x4B\x88\x43\x57\xC0\x04\xC9\x11\x26\xCC\xDD\xCF\xC3\x45\x10\xD4\x42\xD4\x3E\x1F\x64\xAE\x61\x3A\x46\x81\x15\x15\x41\x0C\x12\xDB\x40\x52\xFD\x08\xC5\xB7\xF7\x40\xDE\x11\x10\x26\xC5\xC8\x42\xDE\x5B\x21\x1D\x0A\x1E\x41\x2D\x0A\x14\x0C\x2D\x39\x0A\x0E\x0B\x5F\x2F\x0D\x09\x17\x2B\x04\x8C\xAE\x7E\xA2\x81\x14\x14\x15\x56\x2D\xD5\x15\x11\x13\x18\x49\xE6\x40\x22\x1B\x1E\x14\x0F\x3E\x22\x0D\x16\x0A\x22\x3C\x17\x0A\xE7\xA0\xE7\x03\xEB\x09\xF9\x48\xDF\x55\xCC\x0F\x5D\xCD\xD4\x15\x22\x18\x45\xEF\xC4\xFE\xA1\x0D\x09\x0B\x28\x1E\xEA\xE2\x0F\x5D\x3C\x1D\x0A\xEF\x2D\x00\xF2\xF3\xF0\x5E\x00\xF9\x0A\x0A\xBB\xD5\xC5\xD7\x40\x59\xE8\xDB\x51\x5E\x44\x12\xE1\x10\x0B\x18\x58\xF8\xEF\x0B\x21\x2F\x0B\x17\x91\xD6\xDE\xFD\xEE\x17\x2F\x1D\x11\xF1\xF9\xBE\xE6\xFC\x1D\xF9\xE8\xC9\xFD\x17\xF2\xEC\xDD\x15\xC7\xD9\x09\x64\x8C\xCA\x40\x54\x21\xC4\x14\x09\x18\x7C\xF2\x43\xF8\xA0\x7D\x06\x08\x27\x00\x05\x17\x32\x0F\x05\x6E\x0F\x04\x7B\x7F\x61\x71\xC1\x45\x77\x70\x89\x6B\x71\x0A\x2B\x0C\x0F\xD2\x67\x07\x71\x0B\x45\x4A\x49\x03\x23\x0A\x28\x01\x0B\x08\x45\x05\x68\x42\x22\x8F\x05\x39\x2B\x06\x75\x93\x22\x40\xB5\x0C\x24\x7E\x81\x34\x50\x0B\x3C\x50\x47\x6E\x34\x68\x20\x1A\xB0\x86\x3B\x32\x85\x0E\x0B\x52\x0F\x0D\x38\x53\x0C\x3D\x72\x14\x0F\x03\x18\x23\x88",
"\x81\x00\x08\x04\x24\x1C\x07\x0D\xFF\x41\x46\x1F\x2D\x80\x00\x2F\x91\x84\xA0\x68\x54\x20\x74\x4B\x88\x57\xBB\x2E\x07\x0F\xF2\x24\x0F\x80\x0C\x26\x8B\x00\x07\x8A\x12\xD2\x8D\x89\x27\x91\x88\x87\x80\x48\x84\x00\x44\x37\x8B\x1C\xAE\x01\x06\x3C\x18\x21\x1C\x82\x23\x8C\x34\x8D\x8A\x07\x20\x17\x6E\xC9\x20\x08\x8E\x1B\x61\x27\x88\x22\x02\x80\x08\x12\x74\x72\xCB\x45\x0C\x8F\x20\x02\x48\x4D\x65\x00\x05\x30\x33\x0B\x90\x76\x9B\x36\x19\x83\x2D\x8D\x34\xB6\x34\x92\x64\x99\x8A\x0C\x73\x88\x20\x4E\xB5\x8C\x89\xBB\x3E\x04\x1E\xFA\x87\x91\x3E\x95\x28\x04\x81\x82\x07\x11\x84\x95\x72\x26\x17\x70\x91\x8A\x95\x25\x23\x8F\x99\x93\x32\x13\x92\x20\x95\x91\x46\x1A\xEC\x85\x96\x17\x33\x04\x93\x04\x3E\x91\x2E\xA1\x93\x94\xBC\x65\x90\x04\x7E\x8C\x91\x2A\x83\x93\x73\x56\xAF\x90\x8F\xB1\x8C\x92\x23\x90\x90\x95\x32\x00\x0F\x96\x00\x03\x99\x19\x12\x08\x22\x6E\xB8\x95\x97\x3C\x91\x4D\x11\x70\x25\x88\x84\x25\x99\x89\xDA\x9E\x04\x08\x40\x08\x4C\x5C\x86\x52\x37\xD8\x98\x0B\x3B\xF4\x0E\x04\x1A\x0E\x02\x32\xF7\x94\x8E\x3C\x96\x5E\x4A\x51\xA8\x94\x07\x22\x19\x8E\x31\x88\x99\x99\x75\xBB\x08\x04\xDA\x88\x93\xAD\x39\x8F\x91\x3E\x20\x00\x05\xA8\x95\x61\x40\xFC\x08\x95\xD0\x60\x07\xA0\x58\x13\x09\xA9\x27\x5C\x90\x3C\xA4\x56\x54\x21\x41\x50\x08\x0E\xA2\x04\x7F\x41\xA4\x94\x88\x8B\x53\x1B\x0D\x5F\x50\xB1\x15\xA1\xA0\x29\x13\x94\x08\x73\x9D\x00\x05\x0A\x8B\x9E\xFE\x85\xA7\x49\x83\xA6\x95\x3F\x97\xA0\xA1\xB5\x8A\xA1\x24\xA2\xAE\xA0\x88\xA2\x02\xA2\x20\x14\xA2\x08\x16\xA8\xA2\x8D\xA0\xA2\x44\x88\x9F\xA0\x47\x8D\xAF\x9F\x17\x3B\xA3\x8F\x78\x8A\xA4\x4B\x90\x5A\x98\x8B\xB1\xA3\x9A\xF3\x9B\x94\x25\xAE\x50\x59\x58\x79\x30\x8C\x04\x20\x8C\x16\x64\xA0\x56\x61\x6E\x0E\x97\xA4\x18\x21\x5C\xFA\x9C\xAD\x60\x72\x51\xA7\x3C\x1F\x07\x55\xC7\x95\xA0\x20\x18\xA1\xA8\x78\x8B\xA0\xA0\x54\xA2\x05\x1F\x16\xA3\x9A\x75\xA6\xAE\x1B\x35\xAA\x89\xC4\xAE\xA8\xAF\x7A\xA2\xA0\x56\xC8\x95\x2B\x23\xBF\xAB\xA8\x42\xB5\x98\x61\x86\xB1\xA0\xC4\xBF\x55\xAD\xB2\x4D\x9D\x36\xF3\x91\x9F\x79\xBE\x91\x9F\x08\x28\xB7\x4D\xFC\x9A\x36\xBC\xBB\xAC\xA0\xA7\x97\xB1\x35\x99\xB8\x8A\xA2\x8F\xA1\xA2\x16\xAA\xA9\xE8\x16\xB8\xA0\xA7\x9C\xA1\xAA\x1B\xA1\xA4\x61\xA6\xA2\xB3\x63\x9A\xAE\x51\x5C\xAF\xA4\x08\x5F\xAF\x90\x9A\xB6\xA3\x9F\xA0\x54\x0E\x6B\xC5\xB0\xB7\x90\x3F\xA1\xA1\x81\xA3\xA8\x55\xC6\xA8\xA8\xDD\x81\xA6\xAF\xBD\xA1\xB8\x54\x9E\xA2\xBC\xDB\xA5\xA6\xAA\xD4\xB9\xA8\xA3\x48\xBE\xA5\xA5\xB0\xA2\xA6\xF3\x82\xB4\x74\xF9\x4B\x4E\x4A\xA6\xB2\x06\x86\x18\x21\x7E\xFA\x98\xA6\x3C\xBA\xA1\xBD\x94\xB6\xBA\x6C\xB5\xB4\xB6\x86\xA3\xA7\xB6\x47\xB9\xB6\x72\xCD\xA5\xBC\xE0\x8F\xAE\xBC\xC4\xA8\xA6\x7A\xAB\xAC\xBD\x53\xAE\xBB\xB9\xF0\xAC\xB4\x1D\x40\x02\xAC\x5C\x8E\xB2\x56\x68\xA3\x22\x5A\x9F\xC9\x36\x17\x32\x01\x0A\x18\x28\xC4\x5D\x9F\xB6\xAF\xDC\x10\xB7\xB5\x3D\xAC\x93\x80\xB9\x85\xC1\xC1\x87\xC5\xB0\x87\xAF\x90\x89\xEE\x0C\x9C\x51\x73\xBE\x4B\xA5\xBA\xC2\x0B\x36\x0B\xBE\x84\x05\xCB\xB5\xD1\xB3\xBA\x84\x81\xC2\xC6\xA0\x98\xB1\xBB\x9A\xA7\xC0\x77\x8A\xC7\xC2\x06\xCF\xC6\xC1\x53\xB7\xC6\x49\xC7\x8B\xC9\xE3\xAD\xA6\xC2\x5E\xB9\xC1\x74\xC0\x48\x0A\x14\x7D\x30\x4C\x65\xC9\x3B\x1B\xD8\x08\x22\x36\xFA\x9E\xCC\xD2\xA5\x9B\x64\xCE\x5E\x4B\xA4\xB3\xA3\x6D\x6D\x69\xA5\x93\x75\xC4\xA2\x56\x86\x92\xCF\x57\x54\x0E\x9D\xF9\x75\xCC\x40\xCF\x5A\xA6\x70\xC0\x0B\xDC\x08\x2B\xD0\x2C\x07\x4B\x3D\x61\x12\xBF\xA3\xEC\x3F\x8D\x11\x18\x26\xD2\xFA\x93\xD1\x18\x7E\x90\x7C\x2A\x01\x0E\xD0\x75\xD3\x9A\xA6\xBD\xCD\x2E\x47\xEF\x0C\x3E\xF0\x95\xBC\x2E\xF3\x30\x41\x37\xA9\x00\x23\xAF\xD9\xD3\xA9\x80\x4C\xD2\xD9\x67\x60\xD4\xBA\x32\xA4\xAB\xDE\x44\xD4\xC6\x2E\x9A\xC3\x41\xD1\xBB\x1B\xC5\xC4\x21\x23\xFF\xC5\xB5\xFE\xA0\xA0\x97\xBC\xAC\xC9\xEB\x80\xB5\x91\xDA\xB2\xC8\x6E\x93\xAB\xC1\xF0\x97\xCC\xBC\x0F\xC3\xB8\x7A\xDD\xCB\xBD\x2F\xD6\xBF\xC2\xCC\xB3\xA6\x86\xF2\xBE\xB7\x90\xB1\x9D\xDC\x22\x4F\x8D\x0D\x18\x2B\xDC\x7D\xA8\xDD\x0C\xFE\x81\x05\x9A\xBD\x36\xCE\x79\xDA\xD5\xDE\xA6\xC8\xD6\xA0\x94\xA2\xDF\x79\xBD\xD5\x34\xBF\xD1\xB8\x15\x83\x26\x8A\xD3\xA1\x9A\x4E\x70\x31\x78\xF4\x03\x28\x9C\x9C\xAB\x9F\x79\xD9\x34\x92\x9A\x5D\x4A\x37\xC7\x6D\x48\x0B\x13\xED\xD5\x0C\x60\x08\x22\x8E\xFA\x99\xE3\xFD\x98\x8C\x46\xBB\xC8\x90\x31\x64\x4F\x91\x14\xB9\xDC\x80\x25\xE3\x4C\x89",
"\x25\x4F\xC0\xC7\xC2\xD0\x1E\xF0\x42\x4E\x0D\xF2\xA0\xE4\xBA\x3C\xC3\x25\x9E\xCC\xC4\xC5\xB4\x84\x20\x36\x9B\xC7\x0E\xBD\x88\xE0\x32\x3A\x6C\x20\x7A\x68\x9F\x8E\xEA\x90\x08\x88\xC0\x01\x47\x18\xFC\x48\x9B\x0E\x42\xE2\xA9\xDE\x4E\xC4\x1E\xE8\x21\xD6\xCA\x88\xE7\x38\xC6\xA0\xA1\x24\xF8\x8E\xC9\xAE\xE8\xE4\x84\xBB\xD1\xD7\x62\xED\xE7\x1B\x2F\xEE\xA1\x98\xC8\x94\xE6\xF3\x97\xE6\xD5\xA1\x55\xD4\xD2\xAA\xD3\xB4\x42\xD7\x04\xB1\x83\x26\xD9\xFE\xBF\x98\xC6\xCD\xD3\xC4\xA0\x35\xC9\x56\x69\xC9\xC4\xDA\x55\xD6\xDB\x6F\xD8\xD9\xCA\x92\x91\xC4\xD9\x5E\xDC\xA8\x20\xE1\xC0\xAC\x0D\xE4\xC8\xCE\x0A\xE2\x21\xD6\x73\xD4\x9F\x83\xE3\x9C\x0C\xD8\x88\x9C\x9C\xCC\xEB\xD0\x82\x0D\xD2\xD3\x21\xC2\x22\x5A\x9A\xD3\xE8\x71\xB0\x2E\xE2\x0C\xEA\x8A\xA6\xCC\xE2\xD3\x59\xDE\x4B\xE0\x02\x36\x8B\xD9\x9D\xF4\xE9\xCF\xD9\xF0\x00\x59\x68\x9F\xEE\xB4\xFE\xC7\x77\xF8\xF0\x00\x56\x8F\xDD\xEB\xC5\xEF\xF7\xE0\xCA\x8F\xDD\x4C\xEE\xE8\xD4\xDD\xE7\xE9\x81\x3A\x69\xEA\x6B\x57\xEA\xE7\xF0\x29\xF4\x80\x31\xF0\xFB\x14\xF2\xBB\x3A\x9D\xC9\x9B\x1D\xDD\xFB\xC4\x3D\xEE\xAF\x1B\xAA\xC8\x20\xF6\xCD\xB1\xFD\x77\xA9\xDA\x5E\xCB\xD3\xB3\x82\x82\xF1\x46\x84\xFB\x37\x66\xB9\xC0\x05\x1D\xD7\xF1\x39\xE5\x44\x10\xE5\x4C\x79\xCB\x7B\x45\x41\x48\x4D\x47\x42\x7A\xC9\x15\x36\x1B\x48\x4B\x70\x60\x7B\x0E\x8A\x66\x06\x84\x07\xD2\x73\x10\x62\x4C\x79\x3E\x04\x6E\xE5\x5E\x4D\x08\x1C\x81\x19\x55\x5E\x05\x80\x44\x74\x0D\x7C\x16\x88\x44\xCF\x75\x5E\x19\x85\x7C\xE5\x57\x7E\x94\x4A\x7C\x13\x84\x7E\x17\x80\x7D\xB5\x7A\x6F\x1C\x84\x10\x1E\x8B\x7B\x21\x8C\x45\x24\x86\x44\x26\x8A\x72\xFD\x43\x83\x00\x2C\x82\xAB\x66\x7B\xBA\x1A\x45\x22\x80\x83\x20\x02\x7B\x44\x82\x5D\xA5\x73\x10\xA7\x78\x24\x61\x07\x7C\xBA\x70\x85\x39\x81\x44\x10\x81\x46\x3D\x83\x7B\x4D\x82\x10\x4F\x80\x69\xE4\x7E\x68\x54\x83\x81\x08\x89\x84\x60\x80\x69\x29\x85\x77\x1A\x65\x83\x03\x1E\x81\x06\x74\x74\x13\x8B\x83\x58\x8D\x70\x1A\x67\x86\xBE\x68\x77\xD1\x52\x84\x76\x8D\x6A\x2F\x8B\x73\x58\x88\x64\xB4\x6F\x85\x3B\x66\x01\x18\x12\x88\x3C\x7F\x2A\x2D\x6F\x56\x07\x73\x81\xD5\x72\x10\x7A\x39\x80\xEF\x76\x88\x8A\x5E\x03\x80\x80\x7F\xB9\x1A\x86\x02\x1E\x81\x42\x73\x81\x52\x85\x82\x8F\x85\x56\x8F\x55\x81\xB8\x4D\x75\x9B\x38\x10\xA3\x80\x7E\xAD\x69\x88\x22\x88\x87\x8E\x86\x8A\xFD\x40\x8A\xD9\x4D\x75\x01\x83\x10\x03\x8D\x75\x46\x8A\x83\x18\x19\x35\x17\x8D\x75\x4E\x47\x77\xDA\x4F\x85\xBD\x44\x03\xC0\x43\x10\xC2\x45\x4B\xFE\x4B\x64\x05\x5B\x4C\x7E\x6E\x4A\xC7\x41\x4D\x32\x55\x4B\x40\x0F\x7F\x67\x63\x29\x04\x82\x03\x6E\x68\x10\xD5\x8A\x44\xA3\x72\x67\xC6\x5B\x67\xB9\x64\x51\x45\x08\x67\x4C\x08\x6B\xFB\x6C\x4C\x85\x4A\x8C\xE2\x83\x68\xFA\x37\x8E\xD3\x49\x68\x40\x80\x64\xBC\x88\x83\x32\x01\x6B\x08\x12\x8F\x4A\x8A\x6F\xB5\x6D\x04\xB3\x3A\x8E\x8F\x4B\x7B\x8A\x68\x11\x5D\x8C\x1E\x92\x64\x85\x32\x08\x69\x08\x14\x90\xB2\x70\x85\x9C\x65\x3D\x9E\x6A\x8F\x20\x03\x6A\xF2\x56\x77\x2C\x46\x5F\x42\x65\x03\x7B\x72\x10\x7D\x73\x87\xC9\x60\x78\xF6\x7E\x64\xB3\x50\x65\xB5\x5B\x5D\xD3\x66\x67\x89\x7F\x81\xD7\x60\x02\x52\x52\x5C\x5A\x6B\x6D\x90\x7D\x6D\xC9\x50\x6E\x62\x60\x20\x3A\x7C\x10\x6C\x46\x7E\x18\x18\x7E\x90\x8A\x7E\x34\x0C\x7E\x04\x1E\x7E\x6B\x54\x89\x6E\x0F\x62\x00\x6B\x91\xD8\x50\x6D\x51\x64\x52\x9C\x52\x53\x3B\x6D\x74\x2D\x2F\x8A\x73\x74\x07\x57\x8C\x8A\x45\x83\x03\x59\x74\x10\x5B\x70\x95\x5E\x73\x72\x3E\x9C\x72\x27\x76\x67\x3E\x88\x76\x20\x03\x76\x6B\x74\x55\x6E\x73\x73\xBD\x76\x73\xD3\x4D\x75\xFF\x63\x10\xF1\x45\x4B\xAE\x85\x4B\xE4\x25\x3F\xF7\x10\x8D\x74\x00\x34\x70\x60\x1C\x1C\x04\x12\x02\x2A\x81\x0F\x66\x37\x21\x50\x1C\x1E\x08\x97\x59\x2E\x63\xBB\x70\x26\xBB\x70\x1C\x20\x00\x98\xEE\x1B\x85\x00\x0F\x8F\x61\x06\x24\x50\x80\x1C\xB7\x31\x2E\xEE\x1F\x90\x1A\x67\x27\x1A\x60\x1C\xFE\x32\x99\xE6\x13\x89\x37\x92\x2B\x57\x8B\x63\xC0\x16\x02\x88\x96\x1E\xAE\x86\x95\xA2\x5D\x75\xC0\x18\x02\xA3\x95\x1E\x10\x02\x42\x09\x12\x1C\xC0\x1D\x19\x6F\x93\x9B\xB4\x98\x13\xC2\x1F\x38\x6F\x35\x9B\x00\x0D\x19\xB2\x97\x3F\x26\x23\x10\xC9\x40\x1C\x6B\x93\x54\x6F\x9D\x1C\x05\x1F\x44\xAE\x9A\x9B\xCA\x94\x12\xC2\x1A\x46\xC8\x24\x9B\xBC\x93\x9B\x40\x21\x4D\xC2\x9C\x8B\x6E\x9F\x9A\xCC\x9D\x80\xCB\x9B\x9B\xDB\x91\x71\x0C\x1B\x23\xC4\x97\x77\x04\x17\x46\xD5\x4F\x0F\xB9\x95\x10\xE7\x94\x20",
"\xB1\x9D\x29\x03\x19\x9C\xBA\x9D\x96\xE1\x91\x91\xF2\x99\x4D\xB5\x4A\x98\xEA\x93\x9B\xC3\x95\x4D\xE7\x95\x9D\xF3\x92\x58\xB9\x20\x1C\x9C\x9E\x89\xB2\x26\x9E\xFE\x83\x9B\x17\x38\x11\xEE\x95\x9B\xF0\x95\x4D\xFC\x95\x2B\x98\x43\x54\x8A\x9A\x98\xB4\x99\x9F\xB5\x5B\x9F\xE2\x9A\x96\x03\x1E\x9F\xFA\x70\x1C\x94\x91\x5D\xDD\x95\x9C\xC2\x14\x20\x4E\x7F\xA1\x93\x12\x1C\x4E\x79\x1F\x24\xA1\x1C\x24\x18\x9B\x1F\xA7\x9E\x9F\x12\xA1\xB3\x9D\xA1\x00\x2D\x9B\x0C\x10\x34\xC1\x97\xA1\x2E\x4F\xA0\x0C\xAC\x1C\xC2\x16\x36\x29\xAC\x2D\xC6\x9C\x20\x18\x16\xA1\x6F\x9E\xA2\xEC\x9A\x9B\x01\xA0\x5A\xB9\x14\xA3\xBF\x95\xA3\xC0\x97\x23\x38\xA0\x45\x3A\xA5\x5B\xD8\x21\xA4\x8A\x9F\x38\x29\xA1\xA4\xF9\x11\x8B\xBA\x96\xA4\x46\x3A\x9C\x32\xAE\x25\x9F\x1F\x01\x1F\xAA\x97\x1C\x5A\xA2\x49\x1F\x44\x6A\x44\x9B\x09\xAF\x19\x28\xA1\xA3\x3E\x63\x4F\x63\xA5\xA6\x2A\x8F\x60\x4C\xAE\x29\x94\x20\x00\x74\x6A\x1B\x01\x3A\x9D\x9C\x71\xA4\x8F\x3B\xA6\xB3\x9D\xA6\xA2\x2B\x9C\x61\xAA\x1B\x73\xAD\x9D\x66\xA1\x52\x77\xAF\x3A\x79\xAB\xA7\x74\x0D\xA7\x69\x31\x81\xBD\x11\xA4\xE4\x7B\x9C\x84\xAF\xA5\xBA\x97\xA8\x74\x09\xA8\xDB\x9B\xA8\x22\x2D\xA8\xF1\x13\x29\x90\xA2\xA9\xD3\x34\xA9\x01\x22\x1C\xBF\x7D\x7D\x6C\xAA\x9D\x00\x7F\xA9\x71\xA6\x79\x18\x14\xA6\x8A\xA5\xA7\x1C\x52\xAA\x05\x20\x3B\x7A\xAC\x8D\x91\xA5\xA8\xAF\x14\x49\xBB\x71\xA4\xDD\x7F\x7B\xAD\xA3\xA9\x75\x86\xA8\xB1\xA3\x66\xB3\xA4\xA7\xA5\x6F\x6E\xB8\xAD\x2C\xBC\xA0\x1C\x11\xA0\xAC\x50\x81\xA4\x5C\xAB\x46\x1F\xA9\xA9\xC7\xA0\xA6\xC9\xA0\x20\x9E\xA8\xAC\xCD\xA5\x5E\xCF\xA4\xAA\xD1\xAE\xAA\x95\x18\xAA\x68\xA6\x9B\x04\x3F\xA1\xB8\xA0\x1C\x96\x9E\xA1\xBE\xA2\x10\x8B\x11\x73\xFF\x09\xA0\x04\xAC\x10\x96\x87\x2D\x9D\x12\x8F\x04\x19\xA0\xB4\x9F\xAE\x00\x2C\xA1\xDD\xAE\x25\x8A\x9C\xAF\xDC\xA8\x86\xD1\x58\xAB\x57\x80\x77\x97\x9B\x94\x04\x13\x7D\x4D\x97\xAF\xE9\x26\xA0\xCB\xAC\x10\xFE\xA3\x9B\x00\xBE\x25\x02\xB8\xB0\x00\x2A\x98\xB4\xA0\xAB\x1C\xBE\x25\x17\xB5\xAB\xE1\xAF\x60\x12\xB6\x83\x14\xB3\x33\x08\xAF\xA1\x19\xBC\xA7\xF1\xA0\x39\x01\x7D\xB1\x32\x30\xB2\x75\x81\x73\x0A\xB4\x75\x02\x1C\xB0\xF0\xAF\x9D\x4B\x96\x95\x20\xA9\x9D\x0C\x13\x8A\xCB\x9D\xAE\x38\xBE\x26\x03\x10\x9A\x7C\x89\x34\x85\x82\xA0\x1A\x27\x9E\x27\xB3\x10\x3F\x7C\x2D\xFB\xAB\xB2\xDD\x9F\x99\x3E\x90\xA0\x7C\x8D\x93\x9D\x99\x1B\x05\xBF\xA1\x49\xA7\x88\x44\xA9\xA7\x78\xA0\x96\x65\x28\x23\x3D\xBD\x75\x4F\xB2\x10\x51\xB8\x2D\x9D\x1B\xB6\x00\x03\xB2\xE4\x26\xB5\x5B\xBE\x06\x58\xB2\x93\x63\x5E\x93\x8A\x9E\xB6\xB4\x9F\xB5\x8A\x51\xB6\x78\xA3\xB6\x6A\x75\xB6\x0E\xB3\x10\x10\xB9\x7D\x2E\xBD\x9D\x80\xA8\x11\x15\x0C\xAE\x18\x17\xB3\x0C\x1A\x28\x2C\x92\x16\x1B\xB5\xB3\xF3\x4A\xAE\x49\x1D\x19\x84\x8B\x9D\x44\xBE\xA4\x9C\xB0\x00\x75\x96\xAE\x78\x18\xAA\x41\xA7\x9E\xC7\x7B\x9E\x0C\x1F\xB1\xFD\xAF\xA1\x74\x99\x1C\xA6\xA2\x3D\x9C\x7E\xB1\x1F\xA2\x97\x70\xB0\xAE\x35\xBF\x6E\x3F\xB7\xB9\x18\x17\x01\x8C\xBD\x9D\x8E\x90\x69\xD2\xA5\xA0\xAB\x65\xAD\xC2\x14\xBA\x29\xB8\x10\xA8\xBD\x9E\xB1\xBA\x9D\x9A\x6F\xBB\x0C\x1C\x98\xB0\xBD\x9D\xD3\xA1\xBC\x90\x63\xBB\x07\xB5\xBB\xE5\x57\xBB\x96\xB8\x10\x18\x0B\xBB\xDB\x94\x98\x4B\x83\xB9\xAF\xAD\x95\x01\x26\xAF\xE7\x9A\xB7\x8D\xB0\x6B\x54\xBD\xBD\x93\x25\x98\x2F\xB3\xAF\xBB\x7D\xB5\x24\xB5\xB3\xBB\x7E\xB7\x8E\xA0\xB8\x27\x76\xB6\x3C\xB1\x8A\x11\xB4\xBC\x6F\x9D\x19\xC7\xB2\x10\xD4\xB8\x2D\xDE\xBA\x6F\xE0\xBF\xAB\x43\x8A\x6F\xCF\xB4\xB3\xE1\xBB\x7B\x01\xC5\x9B\xA0\xA2\x12\xE5\xB5\xBC\x40\x79\xBE\xCB\x93\xC0\x01\xBD\xBE\xC0\xAB\x84\x79\xBC\xAC\xF2\xBB\x84\xF4\xB3\xAA\xBA\xA4\xB6\x73\x08\xBF\x3A\x25\x75\x86\xBD\xAB\x88\xB7\x9B\xC0\xBA\xB9\xE7\xBF\x96\x36\xA0\xA5\x9A\xA0\xB3\x79\x8A\xB1\x84\x12\x1C\x9D\x19\x01\x3F\xA9\xBD\x84\x17\x9E\x6F\xAC\x10\xAD\x13\xA4\x2B\xCF\xAA\xB4\xB1\xBE\xEF\x6F\xC1\x32\xCF\xAA\x27\x98\x2A\x05\xC2\xAF\x12\x9B\xB3\x39\xC1\xA4\x9D\x1A\x01\xDC\xB3\xC4\x06\xC0\x00\xA8\x93\xB8\xDE\x9C\x94\x27\xC9\xC3\x40\xB8\x13\xC8\x2B\x01\x53\xC7\xAE\x35\x4F\xA1\xA5\x97\xC5\xE9\xA4\x18\x5B\xA1\xC6\xA1\xB3\xC6\xDD\x95\xC6\x4D\x95\xC3\x24\x1B\xAA\x2D\xA0\xBA\x00\x06\xBE\x6F\x9E\xC6\x27\xC3\xAE\xBA\xA5\xAA\x18\xC7\xC0\x17\xC7\x2D\x41\xAE\x8A\x5C\xC3\xC8\x84\xC5\xC8\x5D\xC4\x18\x8F\x37\x9F\xFD\xBD\xC2\xE4\x2F\xC2\x21\x15\xB7\xC5\x17\xB7\x73\xB0\xC7\x49",
"\x10\x1C\x1D\x06\xC8\x24\xA1\xA4\x6A\xAA\xC6\xDC\x9F\x96\xD0\xA1\x68\xAD\xB2\xC6\x7F\xAA\xC2\x76\xBD\x9D\xD1\x9E\xC9\xE4\xA0\xCA\x74\xC7\x12\xA3\xC4\x1B\x49\xBA\x9C\xA7\xC4\x2E\x9F\xCF\x2C\xA1\xCB\xC6\x9C\x75\xA2\x24\x17\xAD\x82\xAB\xC8\x3E\xC8\xB1\xA9\xC4\xCB\xAB\xC4\x49\x70\x61\xA4\xC0\x1F\xBF\x98\xC3\x9B\x5A\xA4\x44\x9C\xCF\xAD\xD5\xB4\xC4\xD7\xBA\xC9\xAF\xCD\xA5\x74\xC6\xCC\xB4\x9F\xC0\x7A\xCF\xA8\xE5\xA6\xAC\xAE\xB3\xCC\xA4\xC1\xC9\xDD\x9E\xA5\xC6\xBC\xC1\xCE\xC6\xA7\xBE\xCB\xC7\xD9\xC7\xAA\xE8\xCD\xCA\x49\x17\xA9\xCA\x90\xCE\x04\x14\xCD\x70\xA5\xB2\xB7\xA5\xCE\xD8\xCA\xCA\xDA\xC2\xCA\xDC\xC1\xC7\x35\x93\xC7\xF7\xC2\x10\xF0\xCF\x96\xD6\xC4\xCF\x78\xAC\xC7\x31\xCE\xBE\x4B\x82\xAC\xB7\x8C\xCF\xE8\xCF\xCE\xE2\xC5\xC5\x24\x93\xCF\xA8\xC6\xCE\xF6\xCC\x68\x2B\xC5\x86\xEC\x16\xAD\xD1\xC5\x9B\xEE\xC3\x10\xFF\xC4\x2E\x01\xD1\xD1\xF5\xC0\xCC\xFD\xC0\x1A\xC2\xC9\x22\xB0\x98\x11\x21\x07\xCC\x59\xAA\xAA\xFB\xC6\xCA\x8C\xC0\x2E\xB3\xC4\xC3\x05\xD9\xC1\x04\xC7\xC6\x09\x10\x1C\x04\x9A\xD2\x29\xC4\x12\xC3\xAC\xC9\xD7\xC3\xD0\xE7\xC6\x7A\x15\xDB\xBC\xC4\xC8\x11\x25\x0A\xD3\xBA\x99\xCC\x0C\x17\xAD\x85\xC5\xD4\x0C\x17\x02\x48\xD4\x2E\x41\xAF\xC5\x51\xD4\xC9\x38\x10\x1C\x06\xB5\xD5\xB8\xB9\x14\x54\xDE\xD2\x23\xD9\xD5\x0A\xA7\xB6\x6F\xC8\xCB\x49\x19\xC6\x5E\xDB\xD0\x03\x10\xD6\xB4\x98\xC7\xE1\x76\xD5\x84\x12\xC7\xDF\xC4\xC7\x6A\xD3\x9B\x6C\xD3\xA3\x02\xDE\xA8\x04\xDB\xAD\x4C\xCE\xC7\x32\xDA\xD5\x7E\xD4\xC8",
};

			void XmlGetParserBuffer(vl::stream::MemoryStream& stream)
			{
				vl::stream::MemoryStream compressedStream;
				for (vint i = 0; i < parserBufferRows; i++)
				{
					vint size = i == parserBufferRows - 1 ? parserBufferRemain : parserBufferBlock;
					compressedStream.Write((void*)parserBuffer[i], size);
				}
				compressedStream.SeekFromBegin(0);
				vl::stream::LzwDecoder decoder;
				vl::stream::DecoderStream decoderStream(compressedStream, decoder);
				vl::collections::Array<vl::vuint8_t> buffer(65536);
				while (true)
				{
					vl::vint size = decoderStream.Read(&buffer[0], 65536);
					if (size == 0) break;
					stream.Write(&buffer[0], size);
				}
				stream.SeekFromBegin(0);
			}
/***********************************************************************
Unescaping Function Foward Declarations
***********************************************************************/

			extern void XmlMergeTextFragment(vl::collections::List<vl::Ptr<XmlNode>>& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeAttributeValue(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeCData(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeComment(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);

/***********************************************************************
Parsing Tree Conversion Driver Implementation
***********************************************************************/

			class XmlTreeConverter : public vl::parsing::ParsingTreeConverter
			{
			public:
				using vl::parsing::ParsingTreeConverter::SetMember;

				void Fill(vl::Ptr<XmlNode> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
				}

				void Fill(vl::Ptr<XmlText> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->content, obj->GetMember(L"content"), tokens);
				}

				void Fill(vl::Ptr<XmlCData> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeCData(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlAttribute> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					if(SetMember(tree->value, obj->GetMember(L"value"), tokens))
					{
						XmlUnescapeAttributeValue(tree->value, tokens);
					}
				}

				void Fill(vl::Ptr<XmlComment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeComment(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlElement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->closingName, obj->GetMember(L"closingName"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
					if(SetMember(tree->subNodes, obj->GetMember(L"subNodes"), tokens))
					{
						XmlMergeTextFragment(tree->subNodes, tokens);
					}
				}

				void Fill(vl::Ptr<XmlInstruction> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
				}

				void Fill(vl::Ptr<XmlDocument> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->prologs, obj->GetMember(L"prologs"), tokens);
					SetMember(tree->rootElement, obj->GetMember(L"rootElement"), tokens);
				}

				vl::Ptr<vl::parsing::ParsingTreeCustomBase> ConvertClass(vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)override
				{
					if(obj->GetType()==L"Text")
					{
						vl::Ptr<XmlText> tree = new XmlText;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"CData")
					{
						vl::Ptr<XmlCData> tree = new XmlCData;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Attribute")
					{
						vl::Ptr<XmlAttribute> tree = new XmlAttribute;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Comment")
					{
						vl::Ptr<XmlComment> tree = new XmlComment;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Element")
					{
						vl::Ptr<XmlElement> tree = new XmlElement;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Instruction")
					{
						vl::Ptr<XmlInstruction> tree = new XmlInstruction;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Document")
					{
						vl::Ptr<XmlDocument> tree = new XmlDocument;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else 
						return 0;
				}
			};

			vl::Ptr<vl::parsing::ParsingTreeCustomBase> XmlConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				XmlTreeConverter converter;
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> tree;
				converter.SetMember(tree, node, tokens);
				return tree;
			}

/***********************************************************************
Parsing Tree Conversion Implementation
***********************************************************************/

			vl::Ptr<XmlText> XmlText::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlText>();
			}

			vl::Ptr<XmlCData> XmlCData::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlCData>();
			}

			vl::Ptr<XmlAttribute> XmlAttribute::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlAttribute>();
			}

			vl::Ptr<XmlComment> XmlComment::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlComment>();
			}

			vl::Ptr<XmlElement> XmlElement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlElement>();
			}

			vl::Ptr<XmlInstruction> XmlInstruction::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlInstruction>();
			}

			vl::Ptr<XmlDocument> XmlDocument::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlDocument>();
			}

/***********************************************************************
Parser Function
***********************************************************************/

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocumentAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlDocument>();
				}
				return 0;
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocument(input, table, errors, codeIndex);
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElementAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlElement>();
				}
				return 0;
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElement(input, table, errors, codeIndex);
			}

/***********************************************************************
Table Generation
***********************************************************************/

			vl::Ptr<vl::parsing::tabling::ParsingTable> XmlLoadTable()
			{
				vl::stream::MemoryStream stream;
				XmlGetParserBuffer(stream);
				vl::Ptr<vl::parsing::tabling::ParsingTable> table=new vl::parsing::tabling::ParsingTable(stream);
				table->Initialize();
				return table;
			}

		}
	}
}
