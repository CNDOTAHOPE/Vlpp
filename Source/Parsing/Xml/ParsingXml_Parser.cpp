#include "ParsingXml_Parser.h"

namespace vl
{
	namespace parsing
	{
		namespace xml
		{
/***********************************************************************
ParserText
***********************************************************************/

const wchar_t parserTextBuffer[] = 
L"\r\n" L""
L"\r\n" L"class Node"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Text : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class CData : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content (XmlUnescapeCData);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Attribute : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"AttName\");"
L"\r\n" L"\ttoken value (XmlUnescapeAttributeValue)\t\t@Color(\"AttValue\");"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Comment : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content (XmlUnescapeComment);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Element : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\ttoken closingName\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\tAttribute[] attributes;"
L"\r\n" L"\tNode[] subNodes (XmlMergeTextFragment);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Instruction : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\tAttribute[] attributes;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Document : Node"
L"\r\n" L"{"
L"\r\n" L"\tNode[] prologs;"
L"\r\n" L"\tElement rootElement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"token INSTRUCTION_OPEN = \"/</?\"\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token INSTRUCTION_CLOSE = \"/?/>\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token COMPLEX_ELEMENT_OPEN = \"/<//\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token SINGLE_ELEMENT_CLOSE = \"///>\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token ELEMENT_OPEN = \"/<\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token ELEMENT_CLOSE = \"/>\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token EQUAL = \"/=\";"
L"\r\n" L""
L"\r\n" L"token NAME = \"[a-zA-Z0-9:._/-]+\"\t\t\t\t\t\t\t\t@ContextColor();"
L"\r\n" L"token ATTVALUE = \"\"\"[^<>\"\"]*\"\"|\'[^<>\']*\'\"\t\t\t\t\t\t@ContextColor();"
L"\r\n" L"token COMMENT = \"/</!--([^/->]|-[^/->]|--[^>])*--/>\"\t\t\t@Color(\"Comment\");"
L"\r\n" L"token CDATA = \"/</!/[CDATA/[([^/]]|/][^/]]|/]/][^>])*/]/]/>\";"
L"\r\n" L"token TEXT = \"([^<>=\"\"\' /r/n/ta-zA-Z0-9:._/-])+|\"\"|\'\";"
L"\r\n" L""
L"\r\n" L"discardtoken SPACE = \"/s+\";"
L"\r\n" L""
L"\r\n" L"rule Attribute XAttribute = NAME:name \"=\" ATTVALUE:value as Attribute;"
L"\r\n" L"rule Text XText = (NAME:content | EQUAL:content | ATTVALUE:content | TEXT:content) as Text;"
L"\r\n" L"rule CData XCData = CDATA:content as CData;"
L"\r\n" L"rule Comment XComment = COMMENT:content as Comment;"
L"\r\n" L"rule Element XElement = \"<\" NAME:name {XAttribute:attributes} (\"/>\" | \">\" {XSubNode:subNodes} \"</\" NAME:closingName \">\") as Element;"
L"\r\n" L"rule Node XSubNode = !XText | !XCData | !XComment | !XElement;"
L"\r\n" L"rule Instruction XInstruction = \"<?\" NAME:name {XAttribute:attributes} \"?>\" as Instruction;"
L"\r\n" L"rule Document XDocument = {XInstruction:prologs | XComment:prologs} XElement:rootElement as Document;"
;

			vl::WString XmlGetParserTextBuffer()
			{
				return parserTextBuffer;
			}

/***********************************************************************
SerializedTable
***********************************************************************/

const vint parserBufferLength = 4416; // 18926 bytes before compressing
const vint parserBufferBlock = 1024;
const vint parserBufferRemain = 320;
const vint parserBufferRows = 5;
const char* parserBuffer[] = {
"\x00\x0E\x00\x02\x83\x80\x07\x7D\x00\x82\x03\xFF\x45\x08\x82\x83\x86\x81\x21\x6F\x6C\x2F\x32\x37\x84\x87\x02\x86\x00\x17\x82\x94\x21\x37\x32\x27\x30\x6D\x65\x06\x98\x8A\x80\x8E\x86\x00\x10\x92\x94\x98\x8A\x88\x85\x96\x8E\x1E\xA0\xA2\x95\x88\x85\x90\x87\x93\x29\x93\xB4\x84\x8D\x94\x9F\x81\x20\x74\x74\x1F\x81\x93\x94\x86\x9A\x84\x38\x91\xBA\x98\x88\x04\xA7\x9F\xA0\x56\x61\x2C\x35\x33\x9C\x93\x92\x82\x49\xAA\xBB\x83\x8D\x9C\xAF\x80\x98\x43\xD5\x86\xB7\xA3\x81\xAF\xA4\x86\x4D\xE8\x83\x82\x2F\x35\x3A\x36\x32\x61\x72\x39\x25\xA5\x9C\xB1\x87\x81\x39\xAB\xAA\xBB\xB0\x04\xB6\xB6\xB8\x72\xF4\x84\x87\xA8\xA8\xBE\xA4\xBD\x08\xE9\x89\xCB\xBD\xB7\xB5\xB9\xB9\x5B\x82\x84\xC5\xB6\xC2\xAE\xA6\xBE\x7E\x8E\xC1\xD1\xC5\x86\xB8\x00\xB3\x88\x84\x8A\xC2\xDC\xC7\xBF\xC6\xC1\x09\x9E\xE0\xDC\xC3\xD3\x82\xC5\xCC\x80\x90\xE4\x8C\x08\x8C\xDB\x87\x37\x6E\x74\x25\x38\x34\x39\xBC\x8D\x82\x9C\xFF\x76\xC8\x83\xE0\x89\xDD\xDD\xBD\x87\xFF\xC8\xD2\xCA\xD5\xCB\xB3\x2E\xAC\x86\xCD\x31\x91\xDD\xD6\x81\x09\x18\x99\xE2\x80\xA4\x3A\x39\x34\x62\x75\x3A\xDF\x74\xF5\xF0\xF2\xE7\x0F\xC4\x21\x34\x31\x36\xF2\xF3\xAE\x02\xAD\x90\x94\xE5\x31\xDE\xF7\xF2\xD7\x80\x0A\xC4\x2F\x33\x31\x3B\xEA\x74\x37\x74\x78\x7C\x19\x43\x45\x10\x1B\x65\x00\x82\x83\x3F\x0B\x18\x4D\x82\x40\x49\x2E\x13\x1E\x77\x75\x23\x14\x1D\x1A\xB8\x4B\x84\x00\x46\x1B\x82\x4E\x13\x1B\x64\x22\x42\x81\x87\x08\x64\x84\x14\x72\x0B\x8D\x0A\x77\x8A\xDC\x41\x5F\x75\x78\xBA\x64\x84\x40\x89\x6E\x32\x42\x00\x8B\x08\x5B\x70\x01\x77\x2F\xA2\x75\x18\x7A\x00\x36\x12\x54\x55\x03\x26\x46\x91\x7A\xEB\x61\x14\x81\x4B\x63\x38\x6A\x6E\x7D\x02\x8B\x93\x74\x80\x52\x82\x4D\x93\x71\x50\xB7\x79\x7F\x7E\xFD\x7F\x75\x7C\x1D\x55\x80\x00\x1E\x1C\x4A\x67\x13\x1F\x82\x5B\x83\x4C\x7E\x7F\x00\x8F\x88\x42\x9B\x64\xAF\x14\x1F\x81\x09\x9F\x9B\x81\x98\x74\x80\x8A\x00\x46\x7B\x82\x4B\x7A\x77\xE0\x7E\x87\x99\x94\xD2\x42\x49\x9F\x97\x6E\x84\x4E\x9B\x18\x12\x73\x19\x1A\x1B\x31\x61\x4C\x64\x9E\x08\x80\x82\x8F\x40\x34\xB2\x4F\x6C\xA5\x75\x96\x77\x64\x00\x73\x35\x12\x1B\x87\x21\x83\xA7\x7D\xA2\x03\x6E\x91\x87\x84\x72\x15\x87\x84\x6E\x7D\x88\x41\xAF\x9F\x3D\xBA\x66\xAA\x7B\xA8\x82\x4A\xAA\x84\x14\x96\x88\x86\x1B\x97\x82\x49\xA5\x48\xC1\x80\x05\xB2\x89\xC8\x61\x97\x97\x93\x01\x82\x80\x04\x46\x31\x18\x4F\xB3\x6F\xD4\xB5\x4B\x82\x80\xD5\x86\x57\xB7\x7D\xD9\x96\xBB\xB6\x79\xDD\x83\x6F\xB6\x79\xD3\x88\x45\xB9\x12\x4E\x13\x14\x16\x14\x55\x03\x14\x15\x12\x4F\x0E\x1F\x17\x13\x50\x05\x1E\x13\xB1\x03\x6F\x0C\x0F\x0B\x3F\x3F\x6E\x65\x04\x18\x40\xC0\x85\xBA\xEB\xAD\xBF\xB9\xBC\x5F\x03\x1C\x13\x13\x53\x05\x18\xBE\x40\xFC\xAF\x0E\x0C\x67\x06\x18\x44\x06\xC5\x78\x4F\x1D\x10\x14\x4C\x05\x18\x17\x17\x45\x1D\xCD\x12\xBD\x54\x33\xB5\xBF\xBD\x1C\xB9\xBB\xBF\x0B\x37\x96\x48\xC4\x43\x17\xC2\x43\x14\xBA\x47\x1D\xC0\xCA\xC8\x24\xC9\xCB\xC1\xC3\x0F\xC0\x0F\x0B\xCF\x3E\x05\x9C\x5C\x41\xC3\x44\xD6\x80\xCE\x4E\x25\xC4\xBE\xBD\x2D\xC8\x4D\xD2\xBE\xC5\xBA\x84\x42\x8A\x0C\x54\xD0\x01\xC8\x45\x23\xC9\xD2\xCE\x0C\xC5\x1D\xD0\x41\x4F\xFE\x0E\x65\xAC\x85\x77\x46\x81\x14\x55\x01\x1C\x13\xD7\x03\x4F\xDD\x0D\xC5\xDA\xB7\x7D\xCE\x13\x41\x23\xC2\xC0\x42\x77\xDB\x11\x19\x0B\x7A\x01\x1D\x0A\x16\x30\x2D\x09\x0E\x0E\x2E\x1F\x1F\x09\x0B\x5D\x2B\x04\x81\xAE\xFA\x5F\xA1\x10\x15\x54\x16\x1A\xD9\x15\x45\x13\x08\x46\xE5\x02\x62\x0B\x16\x17\x3C\x3E\x02\x09\x17\x2A\x22\x0C\x1F\x09\x9B\xDD\xE7\x08\xE8\x27\x39\x75\xD2\x57\x2E\xCF\x4A\xC6\xD6\x54\x22\x08\x46\xEC\x10\xFB\xB1\x09\x0B\x2D\x28\x0B\xE7\xE1\x3E\x1D\x1C\x1D\x0B\xBB\xED\x0D\xEF\xEF\xC0\xDE\x1D\xED\x0A\x2A\x38\xE2\xC6\xD4\x03\x56\xD5\xD8\x52\x78\x44\x1F\xE1\x10\x2C\x18\x45\xF5\xED\x2F\x21\x0F\x0B\x16\x43\x12\xF4\x15\x10\xDB\xFA\xEE\x17\x0B\x5D\x3E\xE4\xFB\xEE\xE5\xFC\x14\xFB\xF9\xC6\xDD\x18\xF3\xFA\x5D\x12\xC4\xD9\x42\x23\xA9\xCB\x46\xC7\x54\x24\x08\x46\xFE\x02\x62\xFD\xE5\x0F\x22\x07\x04\x08\x2F\x02\x0F\x17\x2E\x0F\x05\xEC\x3C\x6E\xDF\x00\x72\x70\xC2\x46\x70\x71\x29\x0B\x04\x1F\x22\x77\x04\xC6\x4B\x44\x33\x40\x53\x08\x14\x41\x03\x09\x22\x02\x68\x21\x1F\x8F\x07\x1C\x2B\x0B\x74\xC9\x02\x41\x5A\x43\x6E\x37\x40\x58\x03\x0A\x51\x64\x55\x0C\x12\x18\x21\x0C\x82\x2C\x84\x17\xA0\x45\x0C\x2E\x12\x0B\x1B\x72\x43\x0A\xF6\x32\x0C\x0E\xCE\x6D\x7B\x40\x40\x00\x04",
"\x12\x3C\x05\x86\xA3\x57\x86\x0F\x69\x44\x87\x16\x89\x89\x44\x01\x2C\x21\x14\x80\x08\x89\x17\xAE\x05\x87\x71\x34\x0D\x09\x80\x03\x38\x22\x87\x8E\x89\x2F\x82\x6F\x91\x54\x87\x44\xDE\x21\x48\x0B\x65\x94\x0E\x0B\x31\x08\x0A\x8C\x2D\x8A\x20\x47\x89\x8E\x0F\x3A\x00\x04\xBA\x63\x60\x04\x74\x8B\x5B\x97\x20\x0C\x0E\x10\x05\x08\x6D\x6A\x78\x8C\x08\x7A\x89\x36\x3E\xA0\x07\x71\x91\x73\x71\x11\x02\x94\x90\x3A\x06\x94\x0A\xF8\x6C\x92\x93\x7B\x81\x0D\x39\x20\x01\x8D\x40\x10\x6C\x42\x1A\x98\x0B\xEE\x49\x4C\x89\x54\x9E\x90\x7B\x6B\x83\x04\x8C\x25\x90\x8E\x9D\x8A\x3C\x7B\x73\x80\x05\xEE\x53\x7A\x92\x58\x4E\x91\x25\xAD\x9A\x95\x30\x00\x08\x94\x9D\x8F\x0C\x7D\x39\x33\x7E\x81\x31\x51\x97\xBB\x8A\x8D\x0C\x29\x08\x22\x62\xA8\x93\x3E\x00\x4C\x97\x10\x2F\x74\x64\x58\x8C\x58\x04\xB3\x88\x9B\x97\x37\x9F\x52\x2C\x07\x54\x97\x7C\x4B\x87\x35\xC2\x96\x10\x8C\x1D\x98\x95\xDB\x8C\x96\x08\x3C\x02\x04\x22\xB6\x8B\x91\x74\x95\x45\x48\x20\x0B\x0E\x10\x18\x0C\x47\x81\x5A\x36\x20\xB4\x51\x9F\x32\x16\x95\x0F\x20\x08\x04\x08\x22\x02\x62\x11\x06\x92\x04\x9E\x6C\x9E\x3B\xE0\x87\x86\x41\xA1\x57\x89\xF6\x80\x04\x3E\xE3\x9F\x04\x7F\xA7\x9C\x91\x8D\x4F\x51\xA4\x65\x0B\x9F\x80\xA9\x00\x9A\x96\x9B\x98\x2E\x84\xA1\x45\x5E\x80\x07\x97\x1C\xB8\x85\x0C\x35\x08\x22\x92\xA8\x91\xA4\xAC\x81\x04\x1A\xC8\x36\x90\x95\xA2\x91\x0C\x2D\xA0\x98\x80\x31\xAB\x9A\x20\x00\x4B\xA5\xBC\x21\x8A\x40\x56\x68\xA6\x35\xBA\x82\x4E\x45\x0F\x2E\x47\xB1\x56\x89\x9E\xBE\x00\x04\x99\x98\x20\x27\xAF\xA3\x8A\x82\x13\x89\x95\x49\x59\x87\x0E\xF3\x4F\x2C\xC6\x6E\x4D\xA8\x2F\xA7\xA8\x10\x4C\x78\x3B\x15\xAB\x4E\x4B\xB9\x36\xAA\x57\xDD\x40\x40\x17\x32\x00\x0C\x18\x28\xAC\x2A\xDF\xA9\x98\x3A\x80\x0D\x9D\x58\x0B\x55\xAF\x2F\x5E\x0C\x41\xA3\x4D\x4C\x96\x9D\x8E\x4C\xFB\x84\x8F\xBB\x92\x26\x4C\x0A\xAE\x9F\x36\x82\x91\x4F\x39\x55\x54\x92\x96\x8C\xAF\x97\x38\x92\x9B\xDC\x25\x5C\x20\xE5\x5B\xAD\x6E\x52\xA0\xA9\xB7\x3A\xA0\x00\x56\x78\xAA\x2E\xC9\x98\xA8\x5C\x9B\x9B\xA8\xDA\x87\xB3\x64\xB3\x0E\x01\xC8\x25\xB0\x9C\xA2\xB4\x0E\x38\xE4\x95\x8F\xBA\x68\x98\x04\xEA\x94\xA3\x5B\xEE\x90\x9E\x18\x54\xA4\x8E\xF4\x96\xB7\x3D\xF9\x9B\x9F\x7E\xBF\x99\xA0\x70\xA1\xA6\x41\xB6\x85\x55\xC0\x8C\xA6\xA1\xAE\xB0\xA3\x1B\x0E\x50\x53\xB0\x15\xA6\x9F\x17\xB3\x97\x36\x8D\x0A\x01\x23\xA1\x9C\x8E\xE3\x88\xBB\x1D\xE9\x92\x26\x22\xB0\xAD\xB6\x3E\x53\x9E\x8B\x75\x9B\xB6\x7D\xBC\x99\xA0\x7D\x80\xA2\x3F\xC1\xB4\xB9\xDB\xA0\x07\xA0\x2F\x9B\xB7\x71\xAD\xBB\xBB\x41\x91\xA5\xB9\x32\x2F\xB8\x08\x51\xB9\xA3\xD4\x9B\xA5\xBD\x8F\xA3\x21\x64\xA1\xA4\xB2\xAA\xA4\x0F\xB2\x99\xBF\x89\x7B\xDA\xAE\xB3\xD4\xA0\xB4\x86\xDB\x8E\x06\x0D\x27\xB8\x20\x0A\xD6\xB9\xB5\xAB\xBA\xBB\x6B\xB1\xB2\xA1\x77\xA3\xBE\xB6\xE2\xA0\x52\x6E\x81\xB6\xBC\xDF\xA9\xB9\xA0\xB3\xB5\x89\x41\xF4\x80\xBF\x1B\xB2\xBB\x5F\x1A\xCA\xB8\x73\x93\xAA\xBE\xFE\xBE\x89\xB5\xD4\xB7\xC1\xA7\x2A\xB8\xBA\xD6\x8F\xA4\xBB\xEB\x9F\xBB\x87\xE1\xB8\xB7\x21\xF6\x54\xC4\xBD\xA8\xBF\x73\xDE\xB3\xA1\xF6\x83\xB8\xA1\x2F\xCD\xA0\x7D\xAF\xBC\x51\xE5\x92\xA6\xB9\xEA\xBB\xBC\x46\xB7\xCB\xC7\x2D\x83\x39\xAE\xBC\x4D\x56\xAF\x38\x3D\xA9\x81\x0F\xAA\xAE\x62\xD4\xAF\x1A\xD1\x08\x22\x36\xE8\x90\xCD\xAE\x5F\x57\x6A\xBF\x05\x9D\x29\xC2\x94\xC3\x42\xC2\xC4\x91\xD0\x96\xC9\x84\x8B\xA7\x07\x01\xB3\x94\x9C\xE3\xCE\x0D\x06\xFB\xC7\xC1\x54\x91\xC2\x0C\x5F\x98\x20\x46\xFA\xC5\xAD\xFB\x9E\xC5\x72\xC0\xC4\xA3\x3C\xF5\x56\xBD\xB9\xA2\x50\x92\xE7\xBE\x9F\x13\xEB\xBD\xC9\x08\xAF\xC9\x7C\xC6\xB0\xC6\x3B\xF9\x8F\xBE\x34\xD9\xCA\x8D\xB5\xA8\xD0\x0F\xFA\xCA\x37\x5E\xCB\x84\x78\xBA\x3B\x8C\x1E\x18\x26\xD6\xA8\x93\xD5\x19\x2C\x9F\xC6\xD8\x9D\xBB\x9F\x00\x87\x90\xE4\x12\x7C\x08\xCA\x42\x92\x48\x53\x34\xA3\x2C\xBA\xD6\xD0\x3D\x59\x98\xC2\xA9\xAE\x05\x0D\x0C\xD4\x20\x47\xD6\x98\xC3\x3D\xD1\xC4\xA5\x9D\xCA\xD7\x10\xD7\xD5\xBC\x49\xDD\xD2\x7E\xEC\xB1\xD4\x16\xED\xB9\xCA\x75\xDD\xD5\x95\xB3\xC8\xCA\x8B\x9B\xCB\x9B\xB1\xD4\x87\xA0\xF4\xA5\xCC\x81\x27\xC9\xCC\x71\xD8\x36\x0B\x33\x04\x14\x8C\x3D\xDF\xCD\xF8\xC4\xD3\x9C\xDA\xDE\xD7\x75\xA9\xC5\xDB\x45\xCF\xD6\x9F\xFB\x90\xD0\x7F\x82\xD1\xE0\x74\xB9\xC4\x98\xAC\x59\xDE\x37\x03\xE6\xD4\x05\xE5\x0C\x93\xAE\xD7\xD2\x6F\xE4\xBE\xB8\x0D\xFB\xCB\xBC\xBF\x5C\xAA\x00\x3A\x40\x0B\x8A\xA1\xAE\x83\x63\xAC\x4D\x2F",
"\x6B\x8A\xAD\x08\x30\xE7\x11\xA9\xEC\xC7\x0E\xE3\xE0\x37\x76\xA4\x4F\x5F\xF9\xAE\x9D\xC6\x8E\x95\xAF\x3A\xEF\x0C\x60\xF8\x97\xDB\x1D\xC4\xB3\xAA\x83\xB3\x94\xCD\xD4\x9C\x2F\xA2\xC0\x41\xC0\x02\x31\xB1\x84\xBF\xA6\xC0\x04\xC3\x25\xA8\xE1\x88\xA9\xAB\xBA\xD1\xDE\x2A\xBA\xD6\xAC\xB8\xC8\x21\xD8\xC7\x8A\xD6\x5E\xD3\xD1\xE3\xC0\xD5\xCC\x22\xC4\xD6\xD8\x3A\x88\xDC\x2A\x5B\xCC\xD9\x35\x9F\xBF\xD9\x44\xD1\xDF\x06\xD4\xC3\x22\xB5\xD7\xB1\xD2\x82\xF8\xCC\xB6\x7D\xDE\xE3\x88\xF8\x95\xC4\x25\xD9\xCC\xDC\x2F\x82\xD6\x8B\xA4\xD2\xCA\x75\xE8\xD1\x2C\x44\x8A\xD7\xBB\xA9\xBD\xEB\x89\xF3\xAF\x57\xF5\xC0\x23\x0A\xB7\xEE\x0C\xB3\xAE\xC8\x21\x9F\xE7\x88\xE7\x97\xED\xD7\xBF\xDC\xE5\x9E\x82\xFA\xD3\x9F\x81\xD6\x92\xCE\xDB\xA8\x47\x28\xE4\xAF\x97\x77\x64\x21\xBB\x71\xF5\xE5\x93\xB4\xE9\x50\xE4\x09\xF3\x29\x85\xAC\xE6\x5A\xBB\xE9\x9F\x95\xFF\xEB\x19\x21\xEC\x20\x63\xE7\xF6\x6D\xE6\xE5\xBE\x0E\xE2\x01\xD8\x6B\xEA\x93\xB1\xC3\x4A\xD8\x4B\xBA\xD0\x08\x95\xFC\xF1\xCC\x08\x2B\xFA\xCB\xE9\xCF\x57\x05\xDB\xF4\xED\x83\x27\x6F\xA2\xA3\xF2\xEB\x75\xEA\xFA\x8F\x33\x88\x20\xF6\xEA\xFC\xD6\xBA\xEF\x2F\x03\x18\x23\xFE\x81\x05\xAD\xEC\x48\xA5\xE7\xC9\xB4\xE8\x72\x84\x3D\xFF\xF6\x60\x5E\x53\x53\x58\x45\x3F\x4D\x7B\x43\x45\x44\x33\x72\x7B\xB9\x1E\x03\xFA\x7C\x72\x01\x85\x7F\x08\x10\x81\x00\x85\x56\x04\x80\x44\x18\x16\x35\x5E\x43\x81\x5F\x2E\x03\xC2\x7A\x70\xDB\x74\x10\xDD\x7F\x75\x54\x75\x81\x10\x84\x10\x10\x84\x44\xF7\x7D\x67\x1C\x89\x7E\xBA\x60\x75\x00\x01\x59\x5F\x75\x81\x06\x82\x10\x19\x85\x76\xCD\x6F\x25\xEC\x74\x10\xEE\x73\x75\x03\x8E\x43\x16\x85\x35\x07\x88\x75\x18\x67\x83\xB9\x13\x83\x76\x7B\x63\x57\x4E\x83\x5D\x79\x81\xE1\x49\x7D\x10\x7F\x2B\x16\x08\x11\x51\x82\x6F\x4F\x8A\x6F\x23\x8E\x83\xE3\x72\x10\x77\x38\x82\xA2\x75\x85\x16\x7E\x84\x14\x74\x68\x39\x83\x10\xEE\x7C\x79\x49\x89\x45\x2E\x85\x2E\x19\x83\x7A\x9A\x44\x10\x4B\x55\x4B\x69\x8B\x42\x2F\x55\x60\x15\x82\x56\x34\x88\x80\x50\x5B\x4A\x6D\x83\x10\x6F\x89\x24\x95\x73\x87\x15\x88\x68\x19\x89\x55\x37\x59\x46\x25\x83\x10\x12\x89\x46\x74\x8E\x83\x82\x88\x87\x72\x45\x88\xC8\x16\x87\x64\x48\x1C\x67\x8F\x43\x0D\x87\x87\x71\x48\x1C\x4B\x45\x4D\x3E\x73\x86\x02\x1E\x7E\x3E\x7B\x88\x59\x46\x75\x77\x8A\x59\xC1\x4B\x89\x4D\x7E\x73\x46\x82\x59\x6A\x45\x81\x4B\x80\x02\x47\x4E\x73\x0C\x80\x7B\x34\x72\x89\x1A\x83\x5A\x30\x74\x10\x32\x77\x8B\x35\x70\x57\x9C\x79\x73\x78\x56\x48\xAC\x80\x8C\x3B\x71\x58\x4E\x7C\x57\x20\x05\x58\x49\x79\x58\x0A\x84\x07\x40\x0D\x81\x97\x64\x7C\x7D\x6E\x02\x34\x07\x7C\x03\x19\x7C\x65\x74\x47\xA5\x79\x5F\xCF\x7E\x4F\xD1\x75\x6C\xAF\x5F\x76\xD5\x77\x48\x7D\x6C\x74\x8B\x10\x6D\x87\x69\x7E\x11\x64\x03\x79\x72\x10\x7B\x78\x6D\x7D\x78\x71\xA6\x78\x70\x7C\x6A\x70\xE0\x6C\x69\xBF\x5F\x69\x2A\x61\x22\x8A\x75\x5C\x0B\x55\x6A\x8E\x76\x65\xF8\x5B\x4E\x92\x72\x5D\xA9\x58\x7D\xB5\x1B\x79\x5E\x8B\x8A\x66\x84\x03\x9F\x74\x10\xA1\x7E\x7D\x15\x74\x7A\x67\x73\x8F\x81\x79\x70\xDF\x60\x72\xAC\x70\x02\xAE\x7B\x87\x02\x1D\x87\xEC\x1C\x58\xB5\x46\x56\xA7\x48\x10\x25\x91\x8B\xB5\x4A\x4C\xDE\x31\x04\xCE\x48\x58\xB4\x49\x24\x36\x53\x46\x3D\x57\x46\x8A\x82\x03\x6F\x48\x10\x37\x99\x89\xBC\x1C\x7C\x54\x63\x49\x85\x4D\x47\x7F\x49\x36\x4C\x0D\x92\x3F\x92\x6C\x89\x40\x8E\x44\x9E\x48\x7D\x40\x49\x68\x49\x94\x5B\x68\x49\x8C\x5B\x59\x5F\x2D\x6A\xA1\x82\x03\xC6\x48\x10\x57\x91\x8B\x52\x9B\x80\x74\x4B\x4C\x4D\x00\x3B\x4E\x91\x4D\x5B\x9E\x8C\xA0\x44\x1A\x4D\x4D\x5E\x73\x37\x43\xE1\x24\x3F\xF7\x17\x89\x54\x44\x73\xA0\x44\x73\xBF\x1C\x01\x24\x12\x20\xD0\x85\x4F\x6E\x9A\x6B\xBF\x1E\x01\x75\x9A\x25\x73\x79\x5A\x9C\x20\x20\xBF\x10\x02\x7D\x9E\x1E\x60\x87\x79\xB8\x12\x89\x9C\x7F\x1B\xB4\x3E\x2D\xEE\x1E\x91\x00\x00\x92\x61\x00\x24\x2F\x5F\x1B\xFC\x3E\x98\xE6\x10\x89\xBC\x1D\x33\x69\x4F\x1B\x26\x05\x98\xE6\x11\x95\xC1\x41\x26\x3E\x7F\x1B\x28\x00\x9A\xE5\x10\x01\x1F\x49\x10\xC1\x1F\x1B\x9C\x1B\x96\xB0\x91\x9B\x92\x11\x1C\xF9\x1E\x19\xB1\x98\x41\x18\x1F\x9A\xB0\x9F\x5F\x08\x50\x1C\x24\x1E\x51\x6C\x32\x9B\x00\x01\x9C\x9F\x19\x9B\xC2\x97\x8E\xC8\x9B\x8F\x65\x0A\x9B\xAD\x31\x1D\x56\x2E\x93\x74\x0E\x2F\x32\x99\x46\xCC\x15\x10\x8C\x34\x9C\xB1\x94\x9C\x9E\x1C\x9C\xE1\x2C\x9B\x2F\x4C\x9D\x3E\x1D\x9C\x8D\x42\x9D\x66\x34\x43\xD4\x91\x1C\x5B\x48\x9D",
"\xB0\x9A\x9D\xC6\x97\x9C\x2A\x4D\x74\x21\x50\x9E\xAC\x3E\x9C\x00\x03\x9E\x63\x4F\x3C\x3D\x55\x9D\xFF\x07\x59\xC5\x29\x9D\xF7\x93\x10\xF2\x95\x2D\xDE\x97\x43\x01\xA5\x20\xE2\x90\x9D\xBF\x12\x9A\x0A\x21\x1C\x99\x7B\x9A\xC7\x9C\x9E\x0C\x15\xA0\x09\xA5\x4D\xF1\x90\x9B\xCA\x28\xA0\x4A\x59\xA1\x34\x4F\x52\xFA\x97\x88\x02\x1A\x9E\x6B\x90\xA1\x08\x12\xA1\x9F\x26\x96\x54\x45\xA1\x6B\x97\xA1\xB1\x44\x9E\xD0\x36\x9E\xC8\x1E\x9B\x46\x13\x29\xEE\x90\xA0\x33\xA2\x2C\xF6\x30\x00\x9D\x9F\x9F\x77\x1E\xA2\xBC\x1A\x9F\xC4\x90\x99\xAE\x9D\x9E\x20\x45\xA3\xC6\x27\xA3\x39\xA5\x9E\x2D\xA3\x89\xBC\x10\x99\x24\xA8\xA4\xF8\x99\x46\x0E\xA4\xA4\xEF\x99\x9C\x21\x5B\x96\xFA\x9C\x1A\x44\xAD\xA4\x49\xAF\x3C\x95\x9A\xA1\x9B\x42\x87\xB5\x4E\xA3\x5E\xAD\x2D\x9C\x1C\x19\x51\xA2\x9B\x94\x95\x4B\xBF\x10\x99\x92\x9C\xA4\x44\xAC\xA6\x60\xA9\x24\x67\xA2\xA5\x03\xA1\x22\x56\xA1\x1C\x9C\x1E\x51\xB7\x94\xA4\xA4\x93\x96\x13\xA9\x8A\x63\x9F\x0F\x67\xAF\x0F\xC4\x95\x72\x41\xAC\x10\x1D\x08\x11\x73\xA6\xA1\x85\x28\x12\x7E\xA5\xA2\x53\xAC\x8A\x90\x99\xA8\x35\xAA\xA0\x5F\x20\xA2\xF4\x91\x9E\x62\x21\x74\x66\x2F\x1B\x6E\x9C\x8B\x84\xA8\x23\x64\xA2\xAA\x03\x1B\xA8\x29\xAD\xA8\xA5\x90\xA9\x02\x1A\x18\x92\xA4\xAA\xC2\x96\xA9\xB9\x18\xA9\x9A\xAA\xA9\x7E\x52\x74\x73\x0E\xA9\xB4\x8D\x8C\xA1\xAC\x10\x40\xA2\xA4\x04\x16\xA6\x7C\xA8\xAA\x8F\xA9\x42\xAB\xA2\x87\x63\x9E\xA6\x95\xAC\x89\x63\x96\xAA\x33\xA5\xA7\x65\x02\xA5\xFA\x92\x89\xEE\x95\xA6\xB0\x9D\x33\xB1\x5F\xA7\xC9\x9B\x4D\x35\x18\xA7\x09\x92\xA5\x31\xA4\x12\xC4\x97\x59\x87\xA8\x10\x97\x5F\xA3\x17\x84\xA4\xCE\xA2\xAB\x53\xA6\xA2\x2D\x65\x2A\xD8\xA6\xA2\xC7\x89\x1B\xDE\xA0\xAD\xC1\x15\x2C\x99\x7B\xA7\x4E\xA3\x10\x86\xA0\x9B\x9F\xA2\x97\xB3\x94\x12\xB5\x99\xA5\x3A\xA6\x72\x44\xAD\xAF\xCD\x83\x18\xC1\x1C\x9F\x44\xA2\xA2\x04\x1B\xAF\x6B\x96\xB0\xB8\x74\x07\x05\xAA\xA2\xCC\x2F\xAE\x91\xA9\xAA\x44\xAA\x9F\x04\x2E\xA1\xF3\xAA\x9F\x25\x72\xAE\xF4\xA4\x12\x8C\x3E\x82\xFE\x99\xAF\xBA\x28\xAE\x7F\x9B\x63\x05\xA6\xAD\x9A\x25\x77\x04\x1F\x4B\x7A\x9E\xAD\xFA\x90\x99\x59\x8D\xB1\xB4\x93\xB0\x25\xBB\xA5\x42\x49\xAC\x4D\x7B\x4D\xDB\x98\xB2\xF0\x9D\x5E\x30\xA5\x13\xC0\x94\xA4\x67\xAE\x19\x20\xBB\x96\x44\x84\x07\x3F\xBC\xB3\x54\xAD\x5E\x13\xBD\xA8\xF6\x96\xB2\xC5\x9C\xA3\x01\x21\x1C\xD7\x96\xB4\x03\xB9\xB4\xDD\x99\xB2\x00\x2D\xB4\xCD\xA4\xA1\x50\xBC\xA8\x07\xAB\xA2\x03\xB7\x12\xF9\x98\x9E\x18\x1A\xAE\xD5\x27\xB4\xE7\xAE\xB4\xF0\xAE\xB3\xBE\xA7\x9C\xCE\xA1\xB5\x65\xB5\xB1\x67\xBB\x42\xE7\x94\x12\x0A\xB5\xA3\x6E\xB0\x84\x70\xB1\xA9\x72\xB1\xA1\x40\xBF\xB4\x08\x56\xB7\xF4\x93\xB5\xC8\x90\xAF\x3E\x7A\x9F\x0D\xAA\xB5\x54\xBC\xB5\xDD\x2B\xB4\x60\xBE\x9E\x75\xB4\xB6\x89\xB8\xA1\xBC\xAE\xA5\x79\x8D\x1E\xC1\x1C\xB1\x6C\xB4\x2D\x7F\xB4\xAE\x85\xB1\xB7\xA9\x55\xB9\x74\xB2\xB6\x87\xB8\xB9\x9A\xAA\xB8\xCF\x3F\xA4\x2F\xA5\x2D\xD1\xA2\x43\x02\xB4\xB8\x6B\x9C\xB2\x21\x1F\x1B\x87\x9F\x7D\xB8\x1B\xAD\x24\x1C\x19\x1F\x87\x9C\x5A\xA3\xAB\xF3\x9A\xAD\xAA\xAD\x38\xE8\x8A\x20\x83\xA4\x9C\xFD\x73\xAA\x88\xAA\xA8\xC1\xAD\x9C\xC6\xB4\xAC\xC8\xB7\x84\x00\x23\xA9\xA5\xB2\xB8\xA9\x55\xA0\x92\x8A\x8C\xA9\x58\xAB\x0C\x1B\x7F\xBA\xAC\xBC\xB0\x9C\x19\x25\x7C\xAC\xDD\x21\x98\x5F\x26\xB1\xC5\xA9\xBC\x5F\x20\x99\x0E\xBD\xB5\x3D\xBB\xBD\xB0\x9D\xBD\x48\x7F\xBD\xAE\xA4\xB0\x34\x44\x73\xBB\xAF\xA5\x6B\x94\xAD\x0C\x18\xBE\xD9\x2A\xBE\xF2\xA7\xBC\xAC\xAB\x4D\xC8\xA1\xB6\xF3\xBB\x63\x02\xCF\xAA\xAA\xBF\x42\x19\xB1\x1C\x1E\x55\x01\xF3\xA3\xA3\xB3\xBC\x10\x53\x83\xA3\x00\xC1\x2E\x92\x8B\x6E\x57\x6D\xB2\xD4\xB7\xC0\xF8\xBF\xBB\x56\x18\x11\x17\x05\xC1\xD4\x27\xC1\xE6\x2B\xB0\x03\xBE\x89\xB2\x9B\xBB\x15\x7B\xB2\x37\xA7\xAD\x2E\xB3\x10\x30\xBD\x67\xBE\xBF\xAD\x0C\x18\x01\xB5\xBA\xC0\xC8\x9E\xAF\xE1\xB9\xAB\x11\xB8\xC2\x77\xA3\x1B\x18\x19\x01\x3D\xCF\xAB\xB0\x90\x24\xE2\x8F\x1B\x77\x96\x5B\xDD\x2E\xB1\xF4\x74\xC4\x29\xCC\xAD\x0C\x1A\x01\x49\xC7\x9C\x8A\x9E\x85\xBA\xBD\xAD\x54\x4C\x79\xFD\xB3\x18\x85\xA5\xBE\x18\x14\xA9\x43\xA5\xA3\x5B\xC1\x86\x74\x5D\xC5\x0C\x1F\x65\x9C\x78\xBD\x35\xA0\xC3\x84\x61\xBA\x61\x25\xAB\x9D\xA9\xBF\xE2\xB1\xB1\x61\xCA\xAF\x64\xC1\xC4\x01\xC4\xA4\x69\xC8\x98\x6E\x0C\xC6\xC4\x1A\x90\x6A\xCF\x2B\xF0\xB4\xA4\x72\xC4\x57\x74\xCD\xA8\x76\xC7\xAB\x78\xCE\x80\x82\x94\xC4\x57",
"\xA8\x11\x1B\x09\xC5\xC2\x99\x97\x38\xC5\xC3\xBE\x42\x6B\x7D\x6B\xC7\x92\x14\x9C\x2E\xC3\xAE\x3A\x80\xBD\x35\xAA\xC9\x0A\x7E\xC4\x2C\x8D\x67\x90\x93\xCA\xB0\x9F\xC4\x3E\x21\xBA\x88\x69\x69\xB6\x24\xC8\x46\x34\x85\x87\xC9\x21\xC4\x9C\x38\xA4\xC9\x2A\xA6\xC3\xA3\xA8\xC7\x69\xAA\xCC\x10\x37\xCA\x70\x90\x9C\xCB\xAF\xCB\xCA\x0A\x72\xCB\x75\x74\xCB\xF6\x4C\xBE\xD5\xB1\xAF\xD1\x94\xC5\x45\xC6\x14\xBF\x16\xC6\xD4\xC1\x9B\xFA\x96\xAF\x98\xC5\xB5\x08\x18\xCD\xC7\x90\xB1\x01\x8C\x9A\x00\xB8\xB3\x7D\xCA\xB3\x02\x10\xCE\x99\xC2\xC4\xE3\xC4\xCE\x46\x1D\xB7\x33\xAC\xB0\x03\x1A\xCE\xB2\x92\xCE\x00\x28\xB8\xAD\xBA\xB9\x8B\xB7\xB1\x8F\xAA\x9F\xBF\x1F\x01\xD9\xC2\xB3\x58\xB2\x2D\xDD\xC2\xC3\x0C\x13\x2C\xCF\xAC\xC9\x1F\x5E\xC9\xA9\xCE\xCE\x35\x1F\x1B\x21\x01\xD0\x16\xC7\xB3\x54\xB4\xCD\xFE\xC6\x4A\x12\xDA\xCD\xF5\xA8\x11\xF7\xA2\xD1\x17\xDC\x10\x25\x09\xD1\x02\xD4\x12\x8F\xB5\xA3\x1B\xC9\xBE\x52\xBA\xCF\x6E\x8C\xB9\x95\x9F\xD1\x08\x17\x02\x22\xDE\x9E\xFA\x95\xB4\x26\xD3\xB7\xD5\x24\xB1\xEB\xB9\xB7\x56\xBA\xC2\x60\x35\xD0\xAC\xB3\x9F\xAE\xB4\x19\x48\xA9\xB6\x46\xCC\x10\xA1\xBD\xCB\x02\x18\xCF\x40\xDA\xD2\x42\xD9\xA4\x3D\x5F\xAF\x46\x10\xBA\x3E\xD7\xAA\x77\xB9\xD3\x54\xB8\xB6\x7B\xB6\xCD\xC5\x41\xD3\x35\xAA\x9F\xF0\xC3\xAD\x36\xD4\x2D\x38\xD5\xC0\x21\xC6\xAC\xC1\x4C\xD5\x68\xD1\xD3",
};

			void XmlGetParserBuffer(vl::stream::MemoryStream& stream)
			{
				vl::stream::MemoryStream compressedStream;
				for (vint i = 0; i < parserBufferRows; i++)
				{
					vint size = i == parserBufferRows - 1 ? parserBufferRemain : parserBufferBlock;
					compressedStream.Write((void*)parserBuffer[i], size);
				}
				compressedStream.SeekFromBegin(0);
				vl::stream::LzwDecoder decoder;
				vl::stream::DecoderStream decoderStream(compressedStream, decoder);
				vl::collections::Array<vl::vuint8_t> buffer(65536);
				while (true)
				{
					vl::vint size = decoderStream.Read(&buffer[0], 65536);
					if (size == 0) break;
					stream.Write(&buffer[0], size);
				}
				stream.SeekFromBegin(0);
			}
/***********************************************************************
Unescaping Function Foward Declarations
***********************************************************************/

			extern void XmlMergeTextFragment(vl::collections::List<vl::Ptr<XmlNode>>& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeAttributeValue(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeCData(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeComment(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);

/***********************************************************************
Parsing Tree Conversion Driver Implementation
***********************************************************************/

			class XmlTreeConverter : public vl::parsing::ParsingTreeConverter
			{
			public:
				using vl::parsing::ParsingTreeConverter::SetMember;

				void Fill(vl::Ptr<XmlNode> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
				}

				void Fill(vl::Ptr<XmlText> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->content, obj->GetMember(L"content"), tokens);
				}

				void Fill(vl::Ptr<XmlCData> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeCData(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlAttribute> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					if(SetMember(tree->value, obj->GetMember(L"value"), tokens))
					{
						XmlUnescapeAttributeValue(tree->value, tokens);
					}
				}

				void Fill(vl::Ptr<XmlComment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeComment(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlElement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->closingName, obj->GetMember(L"closingName"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
					if(SetMember(tree->subNodes, obj->GetMember(L"subNodes"), tokens))
					{
						XmlMergeTextFragment(tree->subNodes, tokens);
					}
				}

				void Fill(vl::Ptr<XmlInstruction> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
				}

				void Fill(vl::Ptr<XmlDocument> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->prologs, obj->GetMember(L"prologs"), tokens);
					SetMember(tree->rootElement, obj->GetMember(L"rootElement"), tokens);
				}

				vl::Ptr<vl::parsing::ParsingTreeCustomBase> ConvertClass(vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)override
				{
					if(obj->GetType()==L"Text")
					{
						vl::Ptr<XmlText> tree = new XmlText;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"CData")
					{
						vl::Ptr<XmlCData> tree = new XmlCData;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Attribute")
					{
						vl::Ptr<XmlAttribute> tree = new XmlAttribute;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Comment")
					{
						vl::Ptr<XmlComment> tree = new XmlComment;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Element")
					{
						vl::Ptr<XmlElement> tree = new XmlElement;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Instruction")
					{
						vl::Ptr<XmlInstruction> tree = new XmlInstruction;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Document")
					{
						vl::Ptr<XmlDocument> tree = new XmlDocument;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else 
						return 0;
				}
			};

			vl::Ptr<vl::parsing::ParsingTreeCustomBase> XmlConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				XmlTreeConverter converter;
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> tree;
				converter.SetMember(tree, node, tokens);
				return tree;
			}

/***********************************************************************
Parsing Tree Conversion Implementation
***********************************************************************/

			vl::Ptr<XmlText> XmlText::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlText>();
			}

			vl::Ptr<XmlCData> XmlCData::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlCData>();
			}

			vl::Ptr<XmlAttribute> XmlAttribute::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlAttribute>();
			}

			vl::Ptr<XmlComment> XmlComment::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlComment>();
			}

			vl::Ptr<XmlElement> XmlElement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlElement>();
			}

			vl::Ptr<XmlInstruction> XmlInstruction::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlInstruction>();
			}

			vl::Ptr<XmlDocument> XmlDocument::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlDocument>();
			}

/***********************************************************************
Visitor Pattern Implementation
***********************************************************************/

			void XmlText::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlCData::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlAttribute::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlComment::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlElement::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlInstruction::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

			void XmlDocument::Accept(XmlNode::IVisitor* visitor)
			{
				visitor->Visit(this);
			}

/***********************************************************************
Parser Function
***********************************************************************/

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocumentAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlDocument>();
				}
				return 0;
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocument(input, table, errors, codeIndex);
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElementAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlElement>();
				}
				return 0;
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElement(input, table, errors, codeIndex);
			}

/***********************************************************************
Table Generation
***********************************************************************/

			vl::Ptr<vl::parsing::tabling::ParsingTable> XmlLoadTable()
			{
				vl::stream::MemoryStream stream;
				XmlGetParserBuffer(stream);
				vl::Ptr<vl::parsing::tabling::ParsingTable> table=new vl::parsing::tabling::ParsingTable(stream);
				table->Initialize();
				return table;
			}

		}
	}
}
namespace vl
{
	namespace reflection
	{
		namespace description
		{
#ifndef VCZH_DEBUG_NO_REFLECTION
			using namespace vl::parsing::xml;

#define PARSING_TOKEN_FIELD(NAME)\
			CLASS_MEMBER_EXTERNALMETHOD_INVOKETEMPLATE(get_##NAME, NO_PARAMETER, vl::WString(ClassType::*)(), [](ClassType* node) { return node->NAME.value; }, L"*")\
			CLASS_MEMBER_EXTERNALMETHOD_INVOKETEMPLATE(set_##NAME, { L"value" }, void(ClassType::*)(const vl::WString&), [](ClassType* node, const vl::WString& value) { node->NAME.value = value; }, L"*")\
			CLASS_MEMBER_PROPERTY_REFERENCETEMPLATE(NAME, get_##NAME, set_##NAME, L"$This->$Name.value")\

			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlNode, system::XmlNode)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlText, system::XmlText)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlCData, system::XmlCData)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlAttribute, system::XmlAttribute)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlComment, system::XmlComment)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlElement, system::XmlElement)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlInstruction, system::XmlInstruction)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlDocument, system::XmlDocument)
			IMPL_TYPE_INFO_RENAME(vl::parsing::xml::XmlNode::IVisitor, system::XmlNode::IVisitor)

			BEGIN_CLASS_MEMBER(XmlNode)
				CLASS_MEMBER_METHOD(Accept, {L"visitor"})

			END_CLASS_MEMBER(XmlNode)

			BEGIN_CLASS_MEMBER(XmlText)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlText>(), NO_PARAMETER)

				PARSING_TOKEN_FIELD(content)
			END_CLASS_MEMBER(XmlText)

			BEGIN_CLASS_MEMBER(XmlCData)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlCData>(), NO_PARAMETER)

				PARSING_TOKEN_FIELD(content)
			END_CLASS_MEMBER(XmlCData)

			BEGIN_CLASS_MEMBER(XmlAttribute)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlAttribute>(), NO_PARAMETER)

				PARSING_TOKEN_FIELD(name)
				PARSING_TOKEN_FIELD(value)
			END_CLASS_MEMBER(XmlAttribute)

			BEGIN_CLASS_MEMBER(XmlComment)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlComment>(), NO_PARAMETER)

				PARSING_TOKEN_FIELD(content)
			END_CLASS_MEMBER(XmlComment)

			BEGIN_CLASS_MEMBER(XmlElement)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlElement>(), NO_PARAMETER)

				PARSING_TOKEN_FIELD(name)
				PARSING_TOKEN_FIELD(closingName)
				CLASS_MEMBER_FIELD(attributes)
				CLASS_MEMBER_FIELD(subNodes)
			END_CLASS_MEMBER(XmlElement)

			BEGIN_CLASS_MEMBER(XmlInstruction)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlInstruction>(), NO_PARAMETER)

				PARSING_TOKEN_FIELD(name)
				CLASS_MEMBER_FIELD(attributes)
			END_CLASS_MEMBER(XmlInstruction)

			BEGIN_CLASS_MEMBER(XmlDocument)
				CLASS_MEMBER_BASE(XmlNode)

				CLASS_MEMBER_CONSTRUCTOR(vl::Ptr<XmlDocument>(), NO_PARAMETER)

				CLASS_MEMBER_FIELD(prologs)
				CLASS_MEMBER_FIELD(rootElement)
			END_CLASS_MEMBER(XmlDocument)

			BEGIN_INTERFACE_MEMBER(XmlNode::IVisitor)
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlText* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlCData* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlAttribute* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlComment* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlElement* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlInstruction* node))
				CLASS_MEMBER_METHOD_OVERLOAD(Visit, {L"node"}, void(XmlNode::IVisitor::*)(XmlDocument* node))
			END_INTERFACE_MEMBER(XmlNode)

#undef PARSING_TOKEN_FIELD

			class XmlTypeLoader : public vl::Object, public ITypeLoader
			{
			public:
				void Load(ITypeManager* manager)
				{
					ADD_TYPE_INFO(vl::parsing::xml::XmlNode)
					ADD_TYPE_INFO(vl::parsing::xml::XmlText)
					ADD_TYPE_INFO(vl::parsing::xml::XmlCData)
					ADD_TYPE_INFO(vl::parsing::xml::XmlAttribute)
					ADD_TYPE_INFO(vl::parsing::xml::XmlComment)
					ADD_TYPE_INFO(vl::parsing::xml::XmlElement)
					ADD_TYPE_INFO(vl::parsing::xml::XmlInstruction)
					ADD_TYPE_INFO(vl::parsing::xml::XmlDocument)
					ADD_TYPE_INFO(vl::parsing::xml::XmlNode::IVisitor)
				}

				void Unload(ITypeManager* manager)
				{
				}
			};
#endif

			bool XmlLoadTypes()
			{
#ifndef VCZH_DEBUG_NO_REFLECTION
				ITypeManager* manager=GetGlobalTypeManager();
				if(manager)
				{
					Ptr<ITypeLoader> loader=new XmlTypeLoader;
					return manager->AddTypeLoader(loader);
				}
#endif
				return false;
			}
		}
	}
}
