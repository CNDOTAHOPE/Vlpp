/***********************************************************************
Vczh Library++ 3.0
Developer: Zihan Chen(vczh)
Parser::ParsingXml.parser.txt

This file is generated by: Vczh Parser Generator
***********************************************************************/

#include "../Parsing.h"
#include "../ParsingDefinitions.h"
#include "../ParsingAutomaton.h"
#include "ParsingXml_Parser.h"

namespace vl
{
	namespace parsing
	{
		namespace xml
		{
/***********************************************************************
ParserText
***********************************************************************/

const wchar_t parserTextBuffer[] = 
L"\r\n" L""
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L"// AST"
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L""
L"\r\n" L"class Node"
L"\r\n" L"{"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Text : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class CData : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content (XmlUnescapeCData);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Attribute : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"AttName\");"
L"\r\n" L"\ttoken value (XmlUnescapeAttributeValue)\t\t@Color(\"AttValue\");"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Comment : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken content (XmlUnescapeComment);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Element : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\ttoken closingName\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\tAttribute[] attributes;"
L"\r\n" L"\tNode[] subNodes (XmlMergeTextFragment);"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Instruction : Node"
L"\r\n" L"{"
L"\r\n" L"\ttoken name\t\t\t\t\t\t\t\t\t@Color(\"TagName\");"
L"\r\n" L"\tAttribute[] attributes;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"class Document : Node"
L"\r\n" L"{"
L"\r\n" L"\tNode[] prologs;"
L"\r\n" L"\tElement rootElement;"
L"\r\n" L"}"
L"\r\n" L""
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L"// Lexer"
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L""
L"\r\n" L"token INSTRUCTION_OPEN = \"/</?\"\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token INSTRUCTION_CLOSE = \"/?/>\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token COMPLEX_ELEMENT_OPEN = \"/<//\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token SINGLE_ELEMENT_CLOSE = \"///>\"\t\t@Color(\"Boundary\");"
L"\r\n" L"token ELEMENT_OPEN = \"/<\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token ELEMENT_CLOSE = \"/>\"\t\t\t\t@Color(\"Boundary\");"
L"\r\n" L"token EQUAL = \"/=\";"
L"\r\n" L""
L"\r\n" L"token NAME = \"[a-zA-Z0-9:._/-]+\"\t\t\t\t\t\t\t\t@ContextColor();"
L"\r\n" L"token ATTVALUE = \"\"\"[^<>\"\"]*\"\"|\'[^<>\']*\'\"\t\t\t\t\t\t@ContextColor();"
L"\r\n" L"token COMMENT = \"/</!--([^/->]|-[^/->]|--[^>])*--/>\"\t\t\t@Color(\"Comment\");"
L"\r\n" L"token CDATA = \"/</!/[CDATA/[([^/]]|/][^/]]|/]/][^>])*/]/]/>\";"
L"\r\n" L"token TEXT = \"([^<>=\"\"\' /r/n/ta-zA-Z0-9:._/-])+|\"\"|\'\";"
L"\r\n" L""
L"\r\n" L"discardtoken SPACE = \"/s+\";"
L"\r\n" L""
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L"// Rules"
L"\r\n" L"//////////////////////////////////////////////////////////////////"
L"\r\n" L""
L"\r\n" L"rule Attribute XAttribute = NAME:name \"=\" ATTVALUE:value as Attribute;"
L"\r\n" L"rule Text XText = (NAME:content | EQUAL:content | ATTVALUE:content | TEXT:content) as Text;"
L"\r\n" L"rule CData XCData = CDATA:content as CData;"
L"\r\n" L"rule Comment XComment = COMMENT:content as Comment;"
L"\r\n" L"rule Element XElement = \"<\" NAME:name {XAttribute:attributes} (\"/>\" | \">\" {XSubNode:subNodes} \"</\" NAME:closingName \">\") as Element;"
L"\r\n" L"rule Node XSubNode = !XText | !XCData | !XComment | !XElement;"
L"\r\n" L"rule Instruction XInstruction = \"<?\" NAME:name {XAttribute:attributes} \"?>\" as Instruction;"
L"\r\n" L"rule Document XDocument = {XInstruction:prologs | XComment:prologs} XElement:rootElement as Document;"
;

			vl::WString XmlGetParserTextBuffer()
			{
				return parserTextBuffer;
			}

/***********************************************************************
SerializedTable
***********************************************************************/

const vint parserBufferLength = 4445; // 18926 bytes before compressing
const vint parserBufferBlock = 1024;
const vint parserBufferRemain = 349;
const vint parserBufferRows = 5;
const char* parserBuffer[] = {
"\x00\x0E\x00\x02\x83\x80\x07\x7D\x00\x82\x03\xFF\x45\x08\x82\x83\x86\x81\x21\x6F\x6C\x2F\x32\x37\x84\x87\x02\x86\x00\x17\x82\x94\x21\x37\x32\x27\x30\x6D\x65\x06\x98\x8A\x80\x8E\x86\x00\x10\x92\x94\x98\x8A\x88\x85\x97\x20\x74\x74\x1F\x81\x93\x94\x85\x92\x86\x27\xA9\x93\x95\x88\x80\x04\x8C\x9F\x02\xB0\xB4\x36\x21\x34\x35\x3A\x91\x3C\x84\xB7\x88\x89\x99\x8B\x9C\x96\x50\x9B\x9D\x93\x98\xA4\x93\x92\x82\x4D\xAA\x89\xA3\x8D\x94\x81\x96\x8E\x1E\xA0\x95\xB6\x97\xAB\x81\xAD\xA7\x0C\xC0\xBD\x83\x82\x27\x35\x3A\x37\x64\x61\x32\x39\x35\x98\x87\xA4\xAC\x03\xBA\xAB\x89\xBF\x9C\xB6\xB6\xB8\x72\xF4\x9B\xA2\x87\xBE\xB1\xBC\xA7\x7B\xEB\xBC\xA2\x8D\xB7\xB5\xB9\xB9\x75\xCA\xA5\xAD\x87\xC2\xAD\xBF\xC5\x00\x0D\xC0\xD0\xC3\xC5\x83\xC8\x00\x67\x89\xC4\x8A\xB3\xD6\xBE\xC7\xC0\x91\x89\x9F\xC1\xDD\xCC\xD3\x80\xB5\x9A\x8F\xC2\xC4\x9C\x00\x8D\xDB\x87\x6F\x6E\x34\x25\x38\x3C\x3A\xBC\x8C\x05\x9D\xFF\x77\xD8\x84\xE0\x88\xDD\xBC\xBE\xC8\xC0\xE9\xD4\xC3\xD5\xCA\x68\xAE\x91\xA8\x9F\x35\x35\x90\xDD\xAE\x82\x89\x18\x8B\xE9\xA1\x98\x39\x69\x62\x35\x3B\xDF\x7D\xF2\xF3\xF2\xCF\x8F\x84\x21\x34\x39\x33\xF3\xF3\x5D\xDC\x87\xD6\xE5\x32\xDF\xF6\xF3\xD9\x80\x2A\xA4\x2F\x33\x31\x3B\xEB\x74\x37\x75\x79\x7C\x02\x6D\x45\x10\x1B\x65\x00\x82\x83\x3F\x0B\x18\x4D\x82\x40\x49\x2E\x13\x1C\x1D\x72\x35\x13\x18\x1D\x69\x39\x6B\x80\x01\x18\x5C\x82\x42\x13\x6F\x24\x12\x4A\x80\x1E\x88\x45\x88\x15\xC9\x4B\x8D\x00\x77\x2C\x9E\x74\x85\x78\xE3\x65\x15\x88\x41\x25\xAE\x12\x59\x67\xDD\x48\x49\x8E\x50\xE0\x62\x7B\x6D\x7A\x00\x36\x15\x53\x51\x02\x26\x46\x92\x7A\xEC\x61\x14\x81\x46\x03\x63\x19\x6F\x6E\xF6\x42\x8B\x91\x4B\x10\x74\x7A\x6F\x94\x4D\x8F\x95\x7D\x80\x02\xB9\x7B\x7D\x7F\xFF\x5B\x98\x96\x40\x70\x32\x1E\x53\x19\x73\x0B\x8E\x97\x40\xFC\x7E\x70\x83\x83\x08\x70\x96\x9B\x1B\x74\x07\x89\x83\x96\x0B\xA3\x90\x02\x9D\x00\x8A\x08\x46\x9F\x02\x6C\x7F\x8A\x8F\x65\x29\x92\x97\x74\x7C\x9B\x90\x9C\x41\x70\xA3\x12\x47\x1C\x69\x2E\x11\x59\x48\x33\xB2\x76\x47\x40\x89\xBA\x65\xA6\x40\x35\xA2\x53\x03\x74\x5E\x58\xA8\x80\x80\x6B\x82\x43\x1D\x1D\x62\x20\x82\x8A\xA1\xF7\x4B\xA3\x40\x9C\x11\x93\x85\x87\x85\x19\xAE\x10\xA0\x42\xB7\x82\xAD\x8D\x8C\xAC\xAF\x7E\xAA\x40\xB0\x92\x84\x86\x85\x18\xB9\x6B\xA4\x00\x9D\xA1\x40\x73\xB1\x27\x89\x7A\x9E\x93\xC8\x51\x97\x7C\x04\x18\x71\x08\x44\xB5\xC0\x59\xB6\x5F\x82\x02\x9A\xB6\x4C\xB7\xF7\x5E\xBB\xB4\xB8\xE7\x62\xBA\x50\xB9\xE7\x58\xB8\x42\xBA\x49\x0E\x13\x14\x15\x52\x15\x13\x10\x15\x49\x0F\x1E\x13\x17\x4F\x10\x15\x12\x13\xCC\x83\x4F\x08\x0F\x2F\x3F\x00\x73\x67\x11\x18\x45\xC0\x84\xEE\xB0\xB2\xBC\xBD\xF6\x9F\x13\x10\x13\x4F\x13\x15\x11\xBF\x02\x41\xCF\x0A\x0F\x9D\x46\x08\x44\x05\x1B\xF9\x5F\x11\x13\x50\x0C\x15\x10\x16\x5F\x05\x12\xC9\x13\xFB\x94\x18\xBE\xBE\xFC\x9D\x8E\xBC\xC0\x2F\x05\x97\xA4\x43\x1C\xF4\xC3\x43\x14\xED\x87\x12\xC9\xC9\x27\xE9\xCE\xC0\xC4\x12\xD4\xC0\x03\x0B\x44\xFE\x0F\xA4\x66\x04\x44\x79\xD0\xA6\x3D\xCE\x1A\xC9\xBE\xFB\xB2\xC8\x42\xD4\xFF\x87\xB9\x8C\x41\x2B\x8C\x49\xD7\x9E\x4D\xEA\xCF\xC1\xC4\x45\x12\xD4\x40\xD5\x3E\x1F\x67\xAC\x5E\x38\x58\xA1\x15\x15\x41\x0C\x12\xDB\x40\x54\xFD\x0A\xC7\xB7\xF7\x42\xDE\x11\x10\x28\xC7\xC8\x42\xDE\x5B\x21\x1D\x0A\x1E\x41\x2D\x0A\x14\x0C\x2D\x39\x0A\x0E\x0B\x5F\x2F\x0D\x09\x17\x2B\x0B\x9F\xAE\x7E\x97\x40\x01\x10\x15\x54\x16\x1D\xD9\x15\x45\x13\x08\x46\xE6\x02\x62\x0B\x16\x17\x3C\x3E\x02\x09\x17\x2A\x22\x0C\x1F\x09\x9F\xE1\xE7\x08\xE9\x27\x39\x7A\xD2\xA5\xD2\x4F\x4F\xC4\xCA\x4E\xE2\x08\x46\xED\x15\xC0\xC1\x09\x0B\x2D\x28\x0F\xE6\xE2\x3E\x1D\x1C\x1D\x0B\xBF\xED\x01\xF3\xF0\xC4\xDE\x11\xF1\x0A\x2A\x3C\xE7\xC7\xD5\x03\x5B\xD8\xD8\x53\x79\x44\x13\xE5\x10\x2C\x18\x49\xF5\xEE\x2F\x21\x0F\x0B\x16\x43\x16\xF4\x15\x10\xDF\xFE\xEE\x17\x0B\x5D\x02\xF8\xFB\xEF\xE9\xFC\x18\xFB\xFA\xCA\xDD\x1C\xF3\xFB\x5D\x17\xC7\xD9\x42\x24\xAE\xCB\x47\xC8\x54\x24\x08\x46\xFF\x02\x26\x7D\xE8\x3D\x02\x05\x13\x20\x07\x05\x72\x0F\x06\x1B\x2F\x0D\x3D\xBF\x41\x73\x70\x85\x67\x71\xE2\x0B\x79\x05\x15\x3C\x0E\x74\x27\x0F\x73\x82\x1D\x30\x49\x29\x10\x09\x08\x43\x05\x0B\xD1\x08\x23\x85\x17\x33\x0B\x05\xAF\x64\x32\x80\x56\x5C\x21\xFB\x42\x27\x56\x58\x1C\x44\x8C\x3B\x35\x66\x84\x35\x81\x86\xDF\x33\x85\x19\x2E\x02\x0B\x37\x34\x4B\x0A\xED\x32\x0C\x1D\x0F\x08\x22",
"\x22\x82\x20\x08\x20\x04\x04\x0F\x38\x83\x51\x18\x7E\x06\x85\x00\x10\x86\x0C\x84\x5A\x5C\x82\x2A\x5C\x89\xBB\x5B\x36\x0B\x40\x82\x2E\x3A\x01\x24\x21\x5F\x80\x00\x12\xCB\x83\x8A\x27\x90\x8A\x8A\x39\x84\x51\x0A\x80\x04\x38\x2C\xBA\x86\x05\x31\x1C\x04\x46\x72\x82\x20\x32\xA9\x8E\x89\x3A\x00\x07\xDD\x28\x60\x05\x3C\xB6\x41\x24\x48\x82\x04\x01\xA0\x03\x73\xCA\x57\x75\x08\x7D\x80\x06\x90\x46\x25\x0C\x10\x21\x0B\x0E\x84\x97\x8F\x6E\x67\x83\x20\x37\xAA\x8E\x36\x95\x85\x8E\x16\xB2\x04\x8E\x84\x1D\x96\x8E\x4D\x9B\x36\x0F\x79\x8B\x8E\x44\xBE\x8A\x2C\x20\x02\x92\x08\x48\x85\x90\xCB\x4C\x08\x73\x89\x8B\x93\x51\x0E\x90\x92\x4D\xA5\x0C\x92\x02\x36\x91\x8C\x6B\x8D\x8C\x5B\xAE\x03\x06\x9D\x84\x23\x27\xBA\x92\x94\x52\xB8\x6E\x94\x20\x1F\x8D\x23\xAA\x94\x90\xCA\x6E\x90\x96\x79\x92\x95\x23\x8F\x91\x93\x50\xA5\x08\x08\xB8\x80\x00\x31\xE5\x02\x02\x8C\x1D\x99\x97\xBE\x9D\x84\x9D\x45\x00\x2E\x23\x88\x26\x9C\x4A\x9B\x9A\x0F\x20\x00\x09\x52\x5A\x99\x53\x74\x19\x98\x16\x70\x9E\x04\x19\x0E\x03\x30\xF7\x95\x8F\x3C\xA3\x5B\x4B\x51\xA9\x94\x07\x22\x1A\x8F\x31\x89\x9A\x98\x24\xBB\x08\x04\xDB\x89\x92\xAE\x3A\x80\x93\x3E\x20\x00\x05\xA9\x97\x61\x40\xFC\x09\x94\xD1\x60\x07\xA0\x58\x13\x08\xAA\x2A\x5D\x91\x3C\xA7\x51\x55\x21\x45\x50\x08\x0E\xA2\x04\x80\x41\xA5\x94\x89\x8E\x53\x1B\x10\x52\x52\xAA\x15\xA1\xA0\x29\x14\x94\x08\x70\x9D\x00\x05\x0B\x88\x9E\xFE\x85\xA7\x49\x83\xA7\x95\x90\x2C\x98\xA3\xB6\x8A\xA2\x24\xA2\xAE\xA0\x88\xA2\x02\xA2\x20\x14\xA2\x08\x16\xA8\xA2\x8D\xA0\xA2\x44\x89\x9F\xA0\x47\x8D\xAF\x9F\x17\x3B\xA4\x8F\x79\x8A\xA4\x4B\x93\x5B\x98\x8B\xB1\xA4\x9A\xF0\x9C\x95\x25\xB1\x53\x58\x5A\x79\x31\x8C\x04\x21\x8C\x16\x64\xA3\x57\x62\x6E\x0D\x9E\xA4\x18\x21\x5C\xFA\x9C\xAC\x62\x75\x51\xA7\x3C\x1F\x07\x55\xC8\x95\xA1\x8B\x88\xA1\xA8\x79\x8B\xA0\xA1\x54\xA2\x05\x1F\x16\xA4\x9A\x75\xA6\xAE\x1B\x35\xAB\x89\xC4\xAE\xA8\xAF\x7A\xA2\xA0\x56\xC9\x98\x94\x20\x00\xAB\xA8\x42\xB6\x98\x61\x86\xB1\xA0\xC4\x82\x5D\xAD\xB5\x4E\x9F\x3E\xF7\x4A\x36\x79\xB4\x9C\x06\xF9\x88\x21\x6A\xB7\xAC\x9E\xDD\x38\xAB\xAF\x04\xA8\x97\x65\xD6\x99\xB3\x2C\x84\xAF\xA1\x11\xB6\xA2\x52\xA2\x76\xA0\x84\x8E\xAC\xA3\x51\xBB\xA1\x48\x84\xB6\xA4\xC9\x88\x9A\xAB\x91\x5C\xAB\x4B\xA0\x0F\xAA\x48\xB4\xA6\xA6\xA3\xA0\x43\x6B\xC6\xB1\xB6\x9F\xB3\xB6\xB6\xB5\xAC\xA3\x48\xB8\xB7\xA8\xDD\x8B\xBE\xB2\xBE\xA2\xB8\x54\x9E\xA2\xBD\xDB\xA5\xA6\xAA\xD4\xB9\xAB\xA3\x49\xBE\xA5\xA5\xB0\xA2\xA6\xF0\x82\xB4\x3C\xA6\xBD\xB4\x3A\x3F\x96\x10\x18\x38\xBE\x3E\xB8\xA9\x8E\x9D\xA9\xBC\xB2\xD6\xBF\xAC\x66\x81\xB3\xA8\xAA\x86\xA8\xA9\xBB\xA1\xA1\x53\xE5\xB1\xB9\xA7\xA6\xBD\xB8\x28\xAA\xBF\x4A\xEC\xB8\x94\xF7\x8C\xB8\xBE\xF5\xA0\x0A\x58\xB9\x9E\xB1\x5A\x68\xAB\x20\x6A\xBD\xC1\x6E\x3F\x91\x0A\x8C\x25\xC4\xAE\x9F\xB6\xAD\x6E\x10\xB0\xB7\x9E\x8D\x97\xBA\x3A\x99\xBB\x60\xDB\xB5\xB1\xC3\x90\x92\xC4\x6E\x0D\x9D\xE4\x51\xBB\x4A\xFA\xA4\xB6\xBE\x36\x1A\xBC\x42\x42\xCC\xB5\x1F\xD3\xB9\xC2\x00\xCF\xC6\x80\xB4\xB4\xC0\xCD\x9B\xBF\xC0\xDE\xB6\xC3\x82\x8E\xCD\xC1\xA9\xB4\xC6\xA4\x48\x88\xC8\x72\xAD\xA5\xC2\xAF\x98\xC7\xC7\x40\x58\x08\x8A\x3D\x3A\x4E\x31\xC9\x38\x8E\x58\x18\x21\x9A\xFA\x93\xCC\x3A\x3E\x9A\xCB\x5A\x5A\x35\x52\xB3\xAB\x6D\xB6\x69\xA1\xCE\x74\x13\xCD\x2B\x87\x97\xCF\x68\x79\xCC\xA2\x54\x1C\x7D\x9F\xD0\x49\xCE\x6A\xAD\xC8\x08\x73\x68\x21\xA2\xD8\x01\x7D\x24\x62\xB5\xD1\xED\x30\x8F\x08\x18\x23\xD2\x7D\x90\xD1\x0C\xFE\x81\x7F\xF5\x03\xDB\x4A\x99\x97\xD2\xC7\x98\x2C\xD1\x75\x7D\x4F\x4F\x4A\x95\x48\x40\x70\x89\x04\x46\x2A\xD6\xD3\x51\xFD\x99\x8F\x43\x13\x75\xCA\x1C\xD2\xCE\x6A\xA7\xD3\x4B\xA0\xCA\x33\x3B\xF5\xBE\xC6\x54\xF1\x02\xC8\x04\x24\xC8\x8F\xAE\xBD\xBE\x80\x99\xCC\xA7\x49\xDE\xAD\x42\xCD\xC6\xB6\x03\xF9\xB3\xA2\xCB\xB3\xC8\x70\xE4\xBE\xC0\xE2\xA8\xBA\xCB\xEB\xBC\xCA\x4F\x96\xCD\xB9\x99\xB5\xBA\xBE\xF5\xB5\x8B\x40\x57\x84\x9E\x71\xB5\x48\x2E\xD2\x71\x7B\x40\x69\x98\xA6\x76\xA2\xB7\xB7\x21\xB2\x9C\xBC\xA2\x40\x8F\x1A\x18\x26\xDE\xFA\x93\xDD\x19\x7E\x91\x04\x33\xFD\x33\xCE\xFD\xD7\xD0\xC0\xA2\xD6\x4B\x3F\xE0\x05\xDF\xF0\x80\x08\xF4\x5A\x35\x93\x36\x61\x4A\x37\x8F\x70\x4C\x16\x0E\xEE\xD6\x30\x18\x26\xE2\xFA\x94\xE3\xAB\xCA\xD8\xC7\x44\xA5\x4F\x4C\x90\x94\xA0\xC1\x80\x4E\xE2\x33\x52\x20\x4D\xDB\xA3\xD9\x9E\xF9\x83\x4F\x3A",
"\x75\xBA\xA6\x1A\xFA\x36\x86\x98\x9C\xC3\x14\xCA\xB5\x86\x04\x37\x84\x8E\xBC\x8E\x87\x73\xE4\x0A\x6F\x04\x3A\x6D\x3A\xB8\xCB\x9C\x85\xED\x42\x9B\x31\xF4\x0D\xC4\x8D\xE0\x4C\x54\xF2\x00\xE3\x08\x30\xEB\x12\xC9\xEE\x9E\xF0\xAB\xAE\xE6\x6E\xA5\xE4\xC8\xF3\xC3\xE5\x4E\xF9\x8F\xE3\x27\xF4\xAA\xCA\x89\x9D\xE4\x78\xB0\xE5\xE9\x5B\x40\xDF\x8F\xBD\xDB\x4A\x17\x37\x00\xD8\x03\x22\xD8\x7F\xFF\x9D\xC5\x64\xF0\xC4\x50\x32\xDC\x57\x93\xCF\xD3\xCE\x29\xE1\xBC\xCA\xD4\xD6\xC8\x49\x90\xC8\xD9\x2D\xDC\xA9\x90\x5E\xC0\xAD\x7D\xE1\xCD\xCD\x74\xC2\x23\x6B\xFE\xD6\xBE\xB9\xE4\x94\x0D\x6C\xA9\x9D\xCD\x45\xE9\xD0\x41\x0B\xD7\xD3\x0F\xC2\x22\xAD\x97\xDC\xE7\x38\xF0\x2B\xE8\x81\x29\x9F\xD2\x45\xEF\xD2\xAB\xBA\x32\xDC\x81\x17\x8F\xD6\xBA\x22\xF6\xCF\x8E\xF0\x01\xAD\x67\xF3\xF5\x6E\xCE\xDF\x8E\xFA\xDD\xF4\x00\x17\x8A\xDF\xB2\xF4\xF0\xED\xB6\xFB\x88\x7D\xC5\xEB\xE1\x00\x19\x47\xC4\xE8\xEA\x36\xA0\xC3\x22\x6F\xCB\xEE\x4D\xDB\x93\xF0\x2E\xCF\xC0\x23\xDD\x53\xEC\xF9\xEE\xB3\xEC\x21\x36\xB8\xC6\xFA\x21\xD8\xE9\xAD\x70\x87\xC4\x84\x25\xFD\xB1\xE2\xEB\xC5\xB1\xFA\xA7\xD9\xC9\x8A\x9A\xD9\x80\xAE\x91\x81\xB4\xCC\xB2\x99\xB8\xC4\xF1\xC9\x26\x9C\x41\x66\x91\xF2\xD9\xDC\x8A\x88\xD9\x48\x44\x97\x79\x1C\x65\x37\x24\xDA\x4D\x66\xA5\x77\x80\x67\x6F\x7F\x74\x08\x7C\x39\x23\x46\x91\x7E\x03\x9A\x73\x10\x9C\x7B\x1E\xED\x1D\x7B\xAF\x76\x81\x61\x0E\x7F\x41\x4A\x74\x0E\x23\x10\x02\x8B\x44\xA8\x73\x81\x02\x15\x81\x49\x2B\x61\xDA\x41\x7A\x0C\x81\x80\x20\x02\x82\x1A\x8E\x03\xAA\x75\x70\xDF\x48\x10\x33\x8D\x75\xB1\x76\x6E\x0C\x83\x7C\x20\x89\x44\x22\x88\x7B\x30\x8B\x63\xB0\x7E\x45\x18\x10\x7A\xB8\x7B\x45\x1D\x88\x82\x10\x81\x84\x3F\x81\x6A\xF0\x43\x83\x04\x15\x83\xE5\x6D\x73\x39\x88\x11\x5B\x31\x82\x2A\x7B\x84\xBA\x6A\x72\xE0\x75\x49\xF4\x4C\x80\x48\x8D\x82\x57\x8F\x6E\xE5\x5E\x84\x03\x15\x83\xC0\x78\x83\x1D\x8A\x83\x47\x4C\x83\x19\x55\x5E\x58\x85\x1A\xB9\x4A\x6F\x5B\x81\x87\xE5\x56\x84\x5D\x4F\x85\xC5\x7E\x86\x28\x87\x75\xB2\x2A\x62\x6E\x06\x01\x18\x10\x88\x35\x7D\x87\x8A\x5C\x81\x5D\x4E\x7C\x02\x1A\x37\x56\x84\x74\x7B\x88\x63\x64\x82\x10\x35\x8B\x73\x0C\x88\x81\x3B\x88\x7E\x84\x8F\x58\x0E\x8C\x74\xD2\x7A\x1B\x9C\x38\x10\x9D\x81\x7D\x0F\x72\x79\x52\x8D\x81\x73\x82\x46\x6C\x84\x75\x99\x89\x4B\x49\x7A\x7F\x03\x1C\x7F\x49\x76\x87\x42\x4A\x86\xA6\x89\x7D\x9B\x8E\x66\xF2\x46\x4B\x7B\x8E\x4B\x34\x01\x4C\x03\x13\x4C\xB6\x4F\x66\xC8\x6F\x7E\xCC\x4B\x67\xAF\x48\x4C\xD2\x42\x53\xB6\x40\x04\xF8\x74\x66\xD3\x1D\x7F\x32\x0B\x66\x08\x10\x8D\x4B\x48\x79\xC6\x43\x59\xD0\x24\x68\x73\x65\x04\x75\x6C\x04\xB4\x66\x70\xC4\x80\x4D\x20\x07\x8D\x9D\x60\x68\x82\x69\x55\x78\x62\x53\x87\x64\x82\x00\x06\x82\xED\x1F\x68\x1A\x85\x4F\x95\x68\x10\xF1\x8E\x82\x49\x29\x69\xE2\x31\x04\xDD\x8E\x69\x1A\x89\x6B\x70\x89\x82\xB8\x72\x4F\x41\x85\x4F\xAC\x68\x10\x03\x9D\x83\x05\x79\x69\xB2\x6E\x34\xF9\x86\x6B\xB8\x7C\x8F\xAF\x1C\x85\xBC\x65\x6A\xB9\x44\x4F\x35\x00\x77\x02\x12\x77\xF5\x57\x64\xC1\x82\x5B\x4B\x68\x5D\xCC\x6A\x5D\x45\x5C\x77\x09\x6A\x6C\xFA\x65\x65\xC3\x57\x65\xD7\x65\x78\xD9\x6A\x5C\xDC\x6F\x65\x00\x2C\x7D\xC5\x13\x56\xE9\x7E\x06\xA5\x8C\x87\x65\x5E\x56\x2E\x04\x03\xE5\x74\x10\xE7\x76\x93\xA0\x5A\x7E\xFF\x41\x59\x48\x6F\x7E\x77\x71\x23\x79\x7B\x1B\x9B\x56\x63\x20\x08\x63\x46\x7C\x10\xCA\x79\x74\x09\x80\x8A\xA8\x63\x03\x50\x74\x10\x52\x72\x95\x1B\x78\x51\x1D\x7F\x75\x26\x7F\x06\x28\x72\x72\x41\x8A\x75\x61\x79\x72\x66\x7C\x72\x3D\x76\x76\xD4\x49\x74\x0E\x9F\x42\x12\x9A\x4D\xB6\x49\x8A\x92\x33\x54\xE6\x28\x3F\xF7\x1B\x8C\x74\x02\x34\x6D\x60\x1C\x1C\x04\x12\x02\x2A\x8E\xEC\x81\x06\x40\x27\x69\xC0\x1E\x01\x7C\x97\x1F\x31\x80\x20\x7A\x21\x84\xC0\x10\x02\x85\x9F\x1E\x6A\x78\x98\x88\x25\x5F\xC0\x18\x3B\xE3\x2E\x98\xBB\x75\x5E\x76\x31\x52\xC0\x10\x40\x95\x97\x1E\x8D\x83\x93\x09\x88\x63\xC0\x16\x02\x8D\x97\x1E\x70\x98\x95\xD8\x11\x39\x49\x70\x1C\x28\x05\x9A\xE6\x10\x01\x23\x49\x10\xC2\x10\x1C\x9D\x13\x97\xB6\x97\x9B\x76\x12\x1C\x8F\x3F\x36\xB8\x90\x00\x9D\x15\x9B\xFA\x36\x22\x03\x1A\x4C\xC0\x17\x8B\x72\x96\x2E\xCD\x15\x10\x50\x41\x9B\xBD\x9D\x9C\x24\x12\x1C\x6B\x47\x2C\xB7\x9F\x9B\xB6\x90\x24\xD2\x45\x9C\x6D\x9B\x4D\x4A\x12\x1C\x1C\x4E\x9C\x03\x10\x9C\x73\x90\x97\xB6\x48\x9D\x2D\x49\x49\x43\x5F\x0F\xBC\x95\x10",
"\xE9\x9B\x24\xB4\x90\x2A\x03\x1C\x9C\xBD\x92\x9E\xC7\x95\x9E\xF4\x9E\x96\x43\x5A\x8E\xEC\x96\x9B\xC6\x96\x4D\xE9\x94\x9E\xB8\x23\x10\x82\x5C\x2B\xC0\x1F\x99\x97\x85\x2B\xE8\x98\x11\xEA\x8D\x9E\x0C\x1A\x8E\xF0\x98\x9B\xF2\x96\x4D\xFE\x94\x10\x68\x46\x4D\x7E\x9E\x9D\x6C\x95\x9F\xDB\x4D\x9F\x6D\x92\xA1\x00\xA5\x60\xC0\x1F\x98\x5B\x26\xA1\x73\x99\x9C\xFF\x0B\x24\xC8\x72\xA2\x84\x12\x1C\xC8\x79\x1F\x28\xA1\x1C\x24\x1B\x9B\x22\xA9\x9E\x9F\x19\xA0\xB6\x90\xA2\xBA\x10\x9E\xC2\x9C\x10\xC9\x25\x06\x11\xA3\x10\x13\xA6\x5B\xD9\x24\xA2\x66\x3D\xA2\xDE\x24\xA2\x30\xA6\xA1\x32\xAE\x9E\xBD\x94\xA0\x37\x95\x2B\x38\xA4\x23\xC1\x94\x9C\x1B\xAE\xA3\xE6\x90\xA1\x41\xA2\x1C\xEA\x8F\x38\x2D\xA4\xA2\xF9\x1C\x8A\xBD\x99\xA4\x48\x3D\x9C\x36\xA4\x07\x9F\x15\x02\x22\xA2\x86\x0E\x6E\xA2\x36\x10\x45\x6B\x47\x9B\x0D\xAF\x19\x2C\xA5\xA3\x3B\x60\x4F\x65\xA7\xA6\x97\x9E\x60\x4F\xA0\x3B\xA1\x22\x10\xE2\x8A\x1B\x03\x36\x80\x91\x76\xA4\x34\x7E\x9D\x6F\xA1\x39\xCE\x93\xA6\x75\xA6\xA1\x68\xAC\x51\x79\xA5\x20\xD3\x1D\xA7\x74\x0F\xA7\x69\x39\x4B\x6D\x64\xA2\x28\x8E\x9C\x85\xA1\xA6\xBD\x98\xA8\x18\x16\xA6\x8A\xA7\xA7\x8C\xA6\x9B\xCF\x28\x67\x92\xA4\x3D\x94\xA9\x22\xC2\x14\x7B\xD6\x7E\xA6\x06\x8D\x8F\x87\xA3\xA7\x8B\x7D\xA9\x76\xA1\x6A\xFA\x6D\xA8\x4C\x23\x33\x00\x00\xA9\x1F\xA0\x84\xB8\x74\xA2\xD6\x74\x7B\xAC\xA3\xA9\xBA\x6F\xAA\x4C\x81\xAB\x0C\x1E\xA9\xDE\x9B\xA8\x21\x56\xAB\xA3\xAE\x67\xC0\x15\xA1\xB9\x47\x69\x24\xAE\xA5\x6C\x42\xA2\x99\xA3\xAC\x62\xA0\xAB\x60\x62\xAB\x9F\xA4\xAB\xE5\x5C\xAC\x8F\xA4\xAA\xAD\xA6\x18\xA7\xAD\x1B\x6A\xA9\x9B\xD7\x22\xA2\xB6\xA0\x1C\x7A\x20\x4F\xBB\xA5\xAC\x3F\x6F\x0F\x0D\xA7\xA0\x0C\x1F\x88\xD9\x2D\x19\x03\x94\x10\x0D\xA7\x9B\xED\xA2\x99\x86\xAF\x90\x13\x95\x5F\xEA\x89\xAF\xD9\xA0\xAF\x00\x26\xAB\x09\x85\x76\xFE\xAE\x94\x47\x78\x9A\x01\x29\x9E\x88\x87\xAF\xDC\xA4\x42\x22\xAD\xAF\x3F\x6F\xAE\x59\x80\x4F\xEA\x88\xAC\xC4\xA9\xB1\xF5\x5B\xAF\xB3\xA9\x85\xFA\x64\xAF\x34\x86\x9B\x9D\x18\x73\xEF\x95\xB1\x91\x97\xB1\xFF\xA2\x10\x6A\x1A\x72\xEA\x88\xB2\x9B\xAA\xAD\x07\xB6\x9B\x09\xB7\x96\x0B\xBA\x23\x0D\xBB\x9A\xC8\x9C\x9D\x9B\x3A\xAE\x22\xA1\x9A\x33\x93\xA0\x83\xAE\x93\x7E\x84\xB2\x4A\x19\x9E\x32\xB2\xB1\x0C\x14\xB0\x02\x10\xB2\x73\x92\xB4\x05\xA9\x1B\x44\xBD\x7D\x32\x93\xB5\x6E\x03\xB0\x22\xAC\xA4\x3F\x9E\x06\x1A\xA8\xAB\x7B\xA0\x00\x60\x7E\x95\x73\x00\x1C\xA7\x99\x74\x48\xB3\x10\x4B\xBA\xA0\x36\x48\x11\x50\xB6\x2E\x52\xBD\xA4\x54\xB3\xA8\x4B\x33\x88\x72\xB9\xB5\x1D\x36\xA1\x5C\xBE\x87\x5F\xB1\x3B\x7E\xB3\xB6\x68\x26\xB6\x3B\xBA\x7D\x28\xA2\xA8\x0C\x15\x01\x40\xBC\x10\x08\xBF\x81\x7C\xAB\x92\x54\x18\xB1\xFD\x8A\x72\xE8\xA6\x13\x9D\x12\x88\xDE\x9B\xAE\xC1\x90\xA5\x1B\x19\x1C\xA5\xA3\x3D\x81\xA2\x1C\x10\xB6\xB2\x13\xBA\xAF\x22\xA8\x97\x9C\xB3\xAE\x94\x15\xAE\x74\x0B\xB1\x22\xA6\x97\x6F\xBD\xB1\x91\xBA\x6F\x23\xAE\xB3\x0C\x17\x01\x89\xBE\x9D\x81\x9A\x81\xCF\xA8\xA0\xA6\x6A\x81\x24\xA1\xBA\x73\x9D\x19\x1C\xB9\xB2\x16\xA9\xBB\x49\x2B\xBB\x0B\xAD\xBB\x49\x2C\xBA\x16\xA0\xAD\x29\x8A\x81\xAF\xB5\xB0\x22\xB5\x5E\xB3\xBF\x9C\x18\x18\x01\xB7\xBE\x9C\x89\x98\x7B\x90\xB0\xB0\xFE\x85\x70\xF2\xA4\x12\x4A\xB2\xBA\x4D\xBE\xB6\x2A\xB8\xAB\x8A\x9D\xB2\x90\x31\xAD\xB8\x7A\xB5\xDD\xA9\x85\x41\x8D\xB7\x61\xB1\xB6\x80\xB5\xB6\x47\x74\x10\x4F\x9A\x7D\x69\xB9\x88\xE4\xB8\x10\xC3\xBF\xB4\xE7\xBE\xB7\xE9\xBA\xA9\xEB\xBF\xBD\x00\x2C\xBC\xC9\xAC\xAB\x05\x71\xBD\x33\xBE\xAD\x0E\x6B\xBF\x00\x0B\xB6\x18\x17\xB2\xE6\xB6\xA1\xDB\xB5\x70\xDD\xBE\xB2\xA6\x6D\xBE\x79\xB9\xC0\xA1\x61\xBF\xA2\xA3\x1D\xF5\xB2\xB8\x0C\xBA\x8A\x84\xB2\xA2\x86\xBA\x68\xD9\xBF\x9D\xB6\x92\x34\x52\xA4\xC0\x2F\xBE\xAE\xCE\x94\xA2\x9D\x19\x01\x44\xA3\xB9\x76\x19\x9E\x71\xAA\xB8\xEA\xB9\x9E\xEA\x8B\xC3\xE6\x2A\xAC\x22\x22\xBF\xDE\xBD\x8F\x52\x53\x5C\x19\xC5\xC0\x92\xBD\xB3\xD6\xBC\x10\x1A\x0B\xC2\x0D\xCA\x6B\x3C\xB5\xC2\x3A\xB6\xC2\xB5\x87\xC3\x4D\xC6\x17\xC7\x2B\x01\x50\xC0\x1A\x1D\xCE\x9C\x67\xB7\xC2\xE7\xAA\x14\x5D\xAD\xC5\x9F\x12\xC1\xE1\x93\xB8\x57\xC2\x9B\x24\x1A\xAA\x31\xA8\xBA\x11\xC2\xA2\x61\xC5\x8B\xE0\xA8\xAB\xBA\xAA\xBE\x2F\xB3\xC0\xCC\x1A\xA2\xF7\xB8\xC5\x7E\xCF\xC7\x80\xC4\xB9\x2F\xAA\xA4\xB8\x94\x9D\x73\x9E\xC2\x62\x15\xB5\x31\x96\xB7\x5D\xBB\x9D\x24\x10\x1C\x1D\x01\xC8\x85\xB2\x1C\x6C",
"\xAD\xC5\x75\xCE\xB7\x77\xC2\xAC\x9E\xB5\xA9\xBA\x94\xB7\xCD\x96\xC8\xE6\x2D\xAC\x84\x6D\xB9\xE4\xAA\x80\xBD\x16\xA9\x9E\xCD\x9B\xA0\xC2\x2E\xA2\xC1\xA2\x70\xC7\x12\x91\x79\xA2\x24\x14\xAD\x6D\xAD\xBF\x04\x17\xC9\x61\xB9\xC9\xA6\xAB\xCB\x9F\xBF\xC8\x18\x1F\x01\x92\xC7\xC3\xBE\xA4\x85\x96\xC1\xC2\x76\xC2\xAE\xC9\xB9\xCC\xCF\xB7\xBC\x24\xA0\x1C\x21\x01\xCC\x5B\xA9\xAA\x43\x85\xCC\x73\x9D\xCA\x7E\xA8\xC7\x1B\xC8\xC1\x63\xC9\x10\xC0\x11\x8F\xD0\xC7\x9B\x5C\xA5\x44\xDF\xC2\xCB\x36\x10\x1C\xFF\xB3\xCE\x45\xA2\x1C\x65\xC6\xA1\xDD\x97\xAC\x21\xB1\xBB\xD4\xB4\xA2\x95\xC8\xA4\x70\xC7\xCE\xB7\x92\xC4\x65\x08\xCB\xB0\x3A\xCB\xD3\x3B\xC9\xA8\xA3\xC8\x56\xB4\xCF\x9A\xC3\x10\xF6\xC2\xA7\x0E\xC1\xAA\xD5\xC1\xAE\xCE\xAF\xCA\x95\x4C\xC9\xB4\x19\xCA\xB8\x90\xA6\xFE\xBF\xCE\xDE\xBD\x86\x78\xA6\xCC\x98\xC8\xCC\xBB\xCE\xCF\xA7\xC2\xCD\x60\x4F\xC6\x03\xD2\x10\x05\xD3\x97\xF8\xCA\xCF\x8E\xAC\xA7\x1A\xDE\xAA\x15\xD1\x84\xC3\xCA\x35\x20\xDB\xD1\x04\xD4\xD1\x1A\xC4\x87\x17\xD9\xD0\xC7\xCB\xD0\xCA\xCB\x79\xCA\xBD\x1E\xD3\xA0\xD1\xB7\x92\xD1\x04\x13\xD2\x41\xC0\xAA\xCB\xA8\xD1\xB9\xC9\xD2\xA5\xCC\xD1\x01\x23\x9B\x18\x17\x02\xE8\xC2\x2E\x24\xAB\xC5\x4F\xDC\xC6\xE5\xCB\x6A\x53\xDA\x2D\x51\xD8\x11\x5C\xCC\xCE\x70\xCE\xB4\x0E\xAA\xC6\xA1\x84\xD5\x76\x1B\xCE\x97\xBD\xD5\x72\xC0\xD6\x00\x2E\xC8\x36\x1E\xC6\x02\xD0\xD3\x02\x1E\xD5\xB7\x93\xC7\xA1\x86\xD2\xB7\xA9\xAB\x48\xD3\xD3\xF0\xBC\xBD\x57\xDB\xD7\x7F\xC0",
};

			void XmlGetParserBuffer(vl::stream::MemoryStream& stream)
			{
				vl::stream::MemoryStream compressedStream;
				for (vint i = 0; i < parserBufferRows; i++)
				{
					vint size = i == parserBufferRows - 1 ? parserBufferRemain : parserBufferBlock;
					compressedStream.Write((void*)parserBuffer[i], size);
				}
				compressedStream.SeekFromBegin(0);
				vl::stream::LzwDecoder decoder;
				vl::stream::DecoderStream decoderStream(compressedStream, decoder);
				vl::collections::Array<vl::vuint8_t> buffer(65536);
				while (true)
				{
					vl::vint size = decoderStream.Read(&buffer[0], 65536);
					if (size == 0) break;
					stream.Write(&buffer[0], size);
				}
				stream.SeekFromBegin(0);
			}
/***********************************************************************
Unescaping Function Foward Declarations
***********************************************************************/

			extern void XmlMergeTextFragment(vl::collections::List<vl::Ptr<XmlNode>>& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeAttributeValue(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeCData(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);
			extern void XmlUnescapeComment(vl::parsing::ParsingToken& value, const vl::collections::List<vl::regex::RegexToken>& tokens);

/***********************************************************************
Parsing Tree Conversion Driver Implementation
***********************************************************************/

			class XmlTreeConverter : public vl::parsing::ParsingTreeConverter
			{
			public:
				using vl::parsing::ParsingTreeConverter::SetMember;

				void Fill(vl::Ptr<XmlNode> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
				}

				void Fill(vl::Ptr<XmlText> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->content, obj->GetMember(L"content"), tokens);
				}

				void Fill(vl::Ptr<XmlCData> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeCData(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlAttribute> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					if(SetMember(tree->value, obj->GetMember(L"value"), tokens))
					{
						XmlUnescapeAttributeValue(tree->value, tokens);
					}
				}

				void Fill(vl::Ptr<XmlComment> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					if(SetMember(tree->content, obj->GetMember(L"content"), tokens))
					{
						XmlUnescapeComment(tree->content, tokens);
					}
				}

				void Fill(vl::Ptr<XmlElement> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->closingName, obj->GetMember(L"closingName"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
					if(SetMember(tree->subNodes, obj->GetMember(L"subNodes"), tokens))
					{
						XmlMergeTextFragment(tree->subNodes, tokens);
					}
				}

				void Fill(vl::Ptr<XmlInstruction> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->name, obj->GetMember(L"name"), tokens);
					SetMember(tree->attributes, obj->GetMember(L"attributes"), tokens);
				}

				void Fill(vl::Ptr<XmlDocument> tree, vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)
				{
					SetMember(tree->prologs, obj->GetMember(L"prologs"), tokens);
					SetMember(tree->rootElement, obj->GetMember(L"rootElement"), tokens);
				}

				vl::Ptr<vl::parsing::ParsingTreeCustomBase> ConvertClass(vl::Ptr<vl::parsing::ParsingTreeObject> obj, const TokenList& tokens)override
				{
					if(obj->GetType()==L"Text")
					{
						vl::Ptr<XmlText> tree = new XmlText;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"CData")
					{
						vl::Ptr<XmlCData> tree = new XmlCData;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Attribute")
					{
						vl::Ptr<XmlAttribute> tree = new XmlAttribute;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Comment")
					{
						vl::Ptr<XmlComment> tree = new XmlComment;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Element")
					{
						vl::Ptr<XmlElement> tree = new XmlElement;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Instruction")
					{
						vl::Ptr<XmlInstruction> tree = new XmlInstruction;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else if(obj->GetType()==L"Document")
					{
						vl::Ptr<XmlDocument> tree = new XmlDocument;
						vl::collections::CopyFrom(tree->creatorRules, obj->GetCreatorRules());
						Fill(tree, obj, tokens);
						Fill(tree.Cast<XmlNode>(), obj, tokens);
						return tree;
					}
					else 
						return 0;
				}
			};

			vl::Ptr<vl::parsing::ParsingTreeCustomBase> XmlConvertParsingTreeNode(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				XmlTreeConverter converter;
				vl::Ptr<vl::parsing::ParsingTreeCustomBase> tree;
				converter.SetMember(tree, node, tokens);
				return tree;
			}

/***********************************************************************
Parsing Tree Conversion Implementation
***********************************************************************/

			vl::Ptr<XmlText> XmlText::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlText>();
			}

			vl::Ptr<XmlCData> XmlCData::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlCData>();
			}

			vl::Ptr<XmlAttribute> XmlAttribute::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlAttribute>();
			}

			vl::Ptr<XmlComment> XmlComment::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlComment>();
			}

			vl::Ptr<XmlElement> XmlElement::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlElement>();
			}

			vl::Ptr<XmlInstruction> XmlInstruction::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlInstruction>();
			}

			vl::Ptr<XmlDocument> XmlDocument::Convert(vl::Ptr<vl::parsing::ParsingTreeNode> node, const vl::collections::List<vl::regex::RegexToken>& tokens)
			{
				return XmlConvertParsingTreeNode(node, tokens).Cast<XmlDocument>();
			}

/***********************************************************************
Parser Function
***********************************************************************/

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseDocumentAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocumentAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XDocument");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlDocument>();
				}
				return 0;
			}

			vl::Ptr<XmlDocument> XmlParseDocument(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseDocument(input, table, errors, codeIndex);
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				return node;
			}

			vl::Ptr<vl::parsing::ParsingTreeNode> XmlParseElementAsParsingTreeNode(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElementAsParsingTreeNode(input, table, errors, codeIndex);
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::collections::List<vl::Ptr<vl::parsing::ParsingError>>& errors, vl::vint codeIndex)
			{
				vl::parsing::tabling::ParsingState state(input, table, codeIndex);
				state.Reset(L"XElement");
				vl::Ptr<vl::parsing::tabling::ParsingGeneralParser> parser=vl::parsing::tabling::CreateStrictParser(table);
				vl::Ptr<vl::parsing::ParsingTreeNode> node=parser->Parse(state, errors);
				if(node && errors.Count()==0)
				{
					return XmlConvertParsingTreeNode(node, state.GetTokens()).Cast<XmlElement>();
				}
				return 0;
			}

			vl::Ptr<XmlElement> XmlParseElement(const vl::WString& input, vl::Ptr<vl::parsing::tabling::ParsingTable> table, vl::vint codeIndex)
			{
				vl::collections::List<vl::Ptr<vl::parsing::ParsingError>> errors;
				return XmlParseElement(input, table, errors, codeIndex);
			}

/***********************************************************************
Table Generation
***********************************************************************/

			vl::Ptr<vl::parsing::tabling::ParsingTable> XmlLoadTable()
			{
				vl::stream::MemoryStream stream;
				XmlGetParserBuffer(stream);
				vl::Ptr<vl::parsing::tabling::ParsingTable> table=new vl::parsing::tabling::ParsingTable(stream);
				table->Initialize();
				return table;
			}

		}
	}
}
